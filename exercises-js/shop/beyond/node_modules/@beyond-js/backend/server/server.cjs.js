"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hmr = exports.__beyond_pkg = exports.BackendServer = void 0;
var dependency_0 = require("@beyond-js/kernel/bundle");
var dependency_1 = require("@beyond-js/kernel/core");
var dependency_2 = require("socket.io");
var dependency_3 = require("http");
const {
  Bundle: __Bundle
} = dependency_0;
const __pkg = new __Bundle({
  "module": {
    "vspecifier": "@beyond-js/backend@0.1.4/server"
  },
  "type": "ts"
}).package();
;
__pkg.dependencies.update([['@beyond-js/kernel/core', dependency_1], ['socket.io', dependency_2], ['http', dependency_3]]);
const ims = new Map();

/*************************
INTERNAL MODULE: ./bridges
*************************/

ims.set('./bridges', {
  hash: 2846923273,
  creator: function (require, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bridges = void 0;
    var _core = require("@beyond-js/kernel/core");
    class Bridges {
      // The bridges' specification in production environment (not requested to the BEE)
      #bridges;
      #promise;
      async initialize() {
        if (this.#promise) {
          await this.#promise;
          return;
        }
        this.#promise = new _core.PendingPromise();
        const done = () => this.#promise.resolve();
        if (typeof globalThis.__bridges === 'object') return done();
        // In production environment get the actions from the actions.specs.json file
        const {
          specifier
        } = globalThis.__app_package;
        const specs = await bimport(`${specifier}/actions.specs.json`);
        if (!specs) return done();
        this.#bridges = new Map(specs);
        this.#bridges.forEach((specs, module) => {
          this.#bridges.set(module, new Map(specs));
        });
        done();
      }
      async get(module) {
        await this.initialize();
        if (this.#bridges) {
          const classes = this.#bridges.get(module);
          return Promise.resolve({
            classes
          });
        }
        // In development environment, request the bridges to the BEE
        const bridges = globalThis.__bridges;
        const response = await bridges.get(module);
        if (!response) return;
        const {
          errors
        } = response;
        if (errors?.length) return {
          errors
        };
        const classes = new Map(response.bridges);
        classes.forEach((methods, key) => classes.set(key, new Map(methods)));
        return {
          classes
        };
      }
    }
    const bridges = new Bridges();
    exports.bridges = bridges;
  }
});

/****************************************
INTERNAL MODULE: ./connection/cache/cache
****************************************/

ims.set('./connection/cache/cache', {
  hash: 3870432203,
  creator: function (require, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Cache = void 0;
    class Cache {
      #socketId;
      #cache = new Map();
      #times = [];
      #EXPIRATION = 30000; // 30 sec of expiration time
      constructor(socketId) {
        this.#socketId = socketId;
        setInterval(this.#clean, 1000);
      }
      #clean = () => {
        if (!this.#times.length) return;
        const expired = Date.now() - this.#EXPIRATION;
        let rq = this.#times[0];
        if (rq.time > expired) return;
        // Expire item
        this.#times.shift();
        this.#cache.delete(rq.key);
      };
      has(key) {
        key = `${this.#socketId}.${key}`;
        return this.#cache.has(key);
      }
      get(key) {
        key = `${this.#socketId}.${key}`;
        return this.#cache.get(key);
      }
      insert(key, value) {
        key = `${this.#socketId}.${key}`;
        if (this.#cache.has(key)) {
          console.error(`Cache key "${key}" already set`);
          this.update(key, value);
          return;
        }
        this.#cache.set(key, value);
        this.#times.push({
          'key': key,
          'time': Date.now()
        });
      }
      update(key, value) {
        key = `${this.#socketId}.${key}`;
        if (!this.#cache.has(key)) {
          console.warn(`Cache key "${key}" not set`);
        }
        this.#cache.set(key, value);
      }
    }
    exports.Cache = Cache;
  }
});

/***************************************
INTERNAL MODULE: ./connection/connection
***************************************/

ims.set('./connection/connection', {
  hash: 3244549256,
  creator: function (require, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Connection = void 0;
    var _executor = require("./executor/executor");
    var _cache = require("./cache/cache");
    const MaxActiveRequests = 60;
    var State;
    (function (State) {
      State[State["Executing"] = 0] = "Executing";
      State[State["Executed"] = 1] = "Executed";
    })(State || (State = {}));
    class Connection {
      #socket;
      #cache;
      #executor;
      #counter;
      #active;
      constructor(socket) {
        this.#socket = socket;
        this.#executor = new _executor.Executor(socket);
        this.#cache = new _cache.Cache(socket.id);
        socket.on('rpc-v2', this.#_onmessage);
      }
      disconnect() {
        this.#socket.off('rpc-v2', this.#_onmessage);
      }
      #_onmessage = message => this.#onmessage(message).catch(exc => console.error(exc.stack));
      async #onmessage(rq) {
        const socket = this.#socket;
        if (typeof rq !== 'object') {
          console.warn('Invalid rpc, request must be an object');
          return;
        }
        if (!rq.id) {
          console.warn('Action id not set');
          return;
        }
        const respond = response => {
          const {
            error,
            message,
            processingTime,
            source
          } = response;
          socket.emit(`response-v2-${rq.id}`, {
            error,
            message,
            processingTime,
            source
          });
        };
        if (this.#cache.has(rq.id)) {
          const cached = this.#cache.get(rq.id);
          if (cached.state === State.Executed) {
            return respond({
              message: cached.response
            });
          } else {
            return; // Continue waiting the response to be ready
          }
        }

        this.#cache.insert(rq.id, {
          state: State.Executing,
          requestedTime: Date.now()
        });
        this.#counter++;
        if (this.#active > MaxActiveRequests) {
          const error = {
            message: 'Max number of active connections achieved'
          };
          return respond({
            error
          });
        }
        this.#active++;
        try {
          const response = await this.#executor.execute(rq);
          const cached = this.#cache.get(rq.id);
          const processingTime = cached ? Date.now() - cached.requestedTime : void 0;
          this.#cache.update(rq.id, {
            state: State.Executed,
            requestedTime: cached.requestedTime,
            processingTime: processingTime,
            response: response
          });
          this.#active--;
          return respond({
            message: response,
            source: 'server',
            processingTime: processingTime
          });
        } catch (exc) {
          this.#active--;
          if (!(exc instanceof Error)) return respond({
            error: {
              message: exc
            }
          });
          const {
            message,
            stack
          } = exc;
          const {
            specifier
          } = globalThis.__app_package;
          const {
            local
          } = await bimport(`${specifier}/config`);
          const error = local ? {
            message,
            stack
          } : {
            message
          };
          console.log(stack);
          return respond({
            error
          });
        }
      }
    }
    exports.Connection = Connection;
  }
});

/********************************************
INTERNAL MODULE: ./connection/executor/action
********************************************/

ims.set('./connection/executor/action', {
  hash: 3788872330,
  creator: function (require, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Action = void 0;
    class Action {
      #error;
      get error() {
        return this.#error;
      }
      #rq;
      get id() {
        return this.#rq.id;
      }
      get module() {
        return this.#rq.module;
      }
      #className;
      get className() {
        return this.#className;
      }
      #method;
      get method() {
        return this.#method;
      }
      get params() {
        return this.#rq.params;
      }
      constructor(rq) {
        if (!rq.id) {
          this.#error = 'Action id not set';
          return;
        } else if (typeof rq.module !== 'string') {
          this.#error = 'Module id is invalid or not set';
          return;
        } else if (typeof rq.action !== 'string' || !rq.action) {
          this.#error = 'Action is invalid or not set';
          return;
        } else if (rq.params !== undefined && !(rq.params instanceof Array)) {
          this.#error = 'Invalid parameters';
          return;
        }
        // The first element is the relative file (without its extension) where the actions class is implemented
        const [, className, method] = rq.action.split('//');
        if (!className || !method) {
          this.#error = `Invalid class "${className}" or method "${method}" specification`;
          return;
        }
        this.#className = className;
        this.#method = method;
        this.#rq = rq;
      }
    }
    exports.Action = Action;
  }
});

/**********************************************
INTERNAL MODULE: ./connection/executor/executor
**********************************************/

ims.set('./connection/executor/executor', {
  hash: 3524280895,
  creator: function (require, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Executor = void 0;
    var _action = require("./action");
    var _bridges = require("../../bridges");
    class Executor {
      #socket;
      constructor(socket) {
        this.#socket = socket;
      }
      /**
       * Execute an action
       *
       * @param rq
       * @return {Promise<{response: (*)}|{error: module.exports.error}>}
       */
      async execute(rq) {
        const action = new _action.Action(rq);
        if (action.error) return {
          error: action.error
        };
        const {
          module,
          className,
          method
        } = action;
        const {
          errors,
          classes
        } = await _bridges.bridges.get(module);
        if (errors?.length) {
          throw new Error(`Errors found getting module "${module}" bridges: ${JSON.stringify(errors)}`);
        }
        if (!classes) {
          throw new Error(`Module "${module}" does not expose an actions bridge`);
        }
        if (!classes.has(className)) {
          throw new Error(`Module "${module}" does not expose a class "${className}"`);
        }
        const methods = new Map(classes.get(className));
        if (!methods.has(method)) {
          throw new Error(`Module "${module}" does not expose a class ` + `"${className}" with a "${method}" method`);
        }
        // Import the bundle
        let bundle;
        try {
          bundle = await bimport(module);
        } catch (exc) {
          throw new Error(`Error loading bundle "${module}": ${exc.message}`);
        }
        const Class = bundle[className];
        if (typeof Class !== 'function') {
          throw new Error(`Bridge "${module}" does not expose a valid class "${className}", it is not a function`);
        }
        if (!Class.prototype.hasOwnProperty(method)) {
          throw new Error(`Class "${className}" of bridge "${module}" does not expose a method "${method}"`);
        }
        const object = new Class(this.#socket);
        if (typeof object[method] !== 'function') {
          throw new Error(`Class "${className}" of bridge "${module}" ` + `does not expose a method "${method}", it is not a function`);
        }
        return await object[method](...rq.params);
      }
    }
    exports.Executor = Executor;
  }
});

/************************
INTERNAL MODULE: ./server
************************/

ims.set('./server', {
  hash: 550941318,
  creator: function (require, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BackendServer = void 0;
    var http = require("http");
    var _socket = require("socket.io");
    var _connection = require("./connection/connection");
    /* bundle */ // import {instrument} from '@socket.io/admin-ui';
    class BackendServer {
      #server;
      #connections = new Map();
      #onConnection = async socket => {
        const connection = new _connection.Connection(socket);
        const connections = this.#connections;
        connections.set(socket.id, connection);
        const disconnect = () => {
          connections.delete(socket.id);
          connection.disconnect();
          socket.off('disconnect', disconnect);
        };
        socket.on('disconnect', disconnect);
      };
      constructor(port) {
        const options = {
          serveClient: false,
          maxHttpBufferSize: 100000,
          cors: {
            origin: ["https://admin.socket.io"],
            credentials: true
          }
        };
        const server = http.createServer();
        const io = this.#server = new _socket.Server(server, options);
        // instrument(io, {auth: false});
        io.on('connection', this.#onConnection);
        server.listen(port);
        typeof process.send === 'function' && process.send({
          type: 'ready'
        });
      }
    }
    exports.BackendServer = BackendServer;
  }
});
__pkg.exports.descriptor = [{
  "im": "./server",
  "from": "BackendServer",
  "name": "BackendServer"
}];
let BackendServer;

// Module exports
exports.BackendServer = BackendServer;
__pkg.exports.process = function ({
  require,
  prop,
  value
}) {
  (require || prop === 'BackendServer') && (exports.BackendServer = BackendServer = require ? require('./server').BackendServer : value);
};
const __beyond_pkg = __pkg;
exports.__beyond_pkg = __beyond_pkg;
const hmr = new function () {
  this.on = (event, listener) => void 0;
  this.off = (event, listener) => void 0;
}();
exports.hmr = hmr;
__pkg.initialise(ims);
//# sourceMappingURL=server.cjs.js.map