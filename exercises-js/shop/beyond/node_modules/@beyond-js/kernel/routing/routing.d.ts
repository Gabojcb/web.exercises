/************
Processor: ts
************/

import * as dependency_0 from '@beyond-js/kernel/core';

// FILE: history\history.d.ts
declare namespace ns_history_history {
    import HistoryPosition = ns_history_position.HistoryPosition;
    import HistoryRecords = ns_history_records.HistoryRecords;
    import Routing = ns_routing.Routing;
    import RoutingMode = ns_routing.RoutingMode;
    /**
     * Beyond keeps its own history list
     * @constructor
     */
    class BeyondHistory {
        #private;
        get position(): HistoryPosition;
        get records(): HistoryRecords;
        get valid(): boolean;
        get current(): string;
        get initial(): number;
        replaceState(state: any, title: string, uri: string): void;
        pushState(uri: string, state: any): void;
        back(): void;
        forward(): void;
        constructor(routing: Routing, Mode: typeof RoutingMode);
    }
}

// FILE: history\position.d.ts
declare namespace ns_history_position {
    /**
     * The position of the navigation is stored this way:
     *      1. In the state of each page (the history.state object), it is stored the position
     *         in which the page is located. To achieve this, the __beyond_navigation_position property
     *         is added to the state object.
     *      2. In the sessionStorage is stored the current position (__beyond_navigation_position)
     */
    class HistoryPosition {
        check(): boolean;
        /**
         * Returns the position from the history.state
         * @returns {number | undefined}
         */
        get value(): number;
        save(position: number): void;
    }
}

// FILE: history\records.d.ts
declare namespace ns_history_records {
    import HistoryPosition = ns_history_position.HistoryPosition;
    interface IHistoryEntry {
        uri: string;
        position: number;
    }
    class HistoryRecords {
        #private;
        get valid(): boolean;
        get entries(): IHistoryEntry[];
        get length(): number;
        get current(): IHistoryEntry;
        get previous(): IHistoryEntry;
        get following(): IHistoryEntry;
        constructor(position: HistoryPosition);
        get(index: number): IHistoryEntry;
        /**
         * Push a uri to the records stored in the sessionStorage
         * @param {string} uri
         */
        push(uri: string): void;
        /**
         * Reset the list of records from the current position
         * This is required when:
         *      1. The list of browsed pages is greater than one (ex: page1 and page2)
         *      2. The user goes back in the history (ex: to position 1: page1)
         *      3. The user navigates another page (ex: page3)
         *
         * This method is required in step 3, to clean the records from position 1, and after this
         * execution, the navigation flow can push page3
         */
        reset(): void;
        updateCurrentURI(uri: string): void;
        save(): void;
    }
}

// FILE: routing.d.ts
declare namespace ns_routing {
    import URI = ns_uri_uri.URI;
    import Events = dependency_0.Events;
    import BeyondHistory = ns_history_history.BeyondHistory;
    enum RoutingMode {
        Hash = 0,
        Pathname = 1
    }
    class Routing extends Events {
        #private;
        get mode(): RoutingMode;
        get history(): BeyondHistory;
        get initialised(): boolean;
        get ready(): Promise<unknown>;
        get uri(): URI;
        missing: (pathname: string) => Promise<string>;
        redirect: (uri: URI) => Promise<string>;
        constructor();
        pushState(uri: string, state?: object): void;
        replaceState(state: object, title: string, uri?: string): void;
        update: () => Promise<void>;
        setup(): void;
        back(): void;
        forward(): void;
    }
    const routing: Routing;
}

// FILE: uri\querystring.d.ts
declare namespace ns_uri_querystring {
    class QueryString extends Map<string, string> {
        constructor(search: string);
    }
}

// FILE: uri\uri.d.ts
declare namespace ns_uri_uri {
    import QueryString = ns_uri_querystring.QueryString;
    class URI {
        #private;
        get uri(): string;
        get pathname(): string;
        get search(): string;
        get qs(): QueryString;
        get hash(): string;
        constructor(uri: string);
    }
}

export import routing = ns_routing.routing;
export import URI = ns_uri_uri.URI;


