/************
Processor: ts
************/

// FILE: base\index.d.ts
declare namespace ns_base_index {
    import IMSpecs = ns_package_ims_im.IMSpecs;
    function resolve(source: string, id: string): string;
    /**
     * This class is used only by beyond/core
     */
    class BeyondPackage {
        #private;
        constructor(exports: any);
        initialise(ims?: Map<string, IMSpecs>): void;
        /**
         * Solve the require function
         *
         * @param source {string} The module from where the require is being triggered
         * @param id {string} The module id being requested
         * @returns {*}
         */
        require(id: string, source?: string): any;
    }
}

// FILE: bimport\bimport.d.ts
declare namespace ns_bimport_bimport {
    /**
     * Import a module, solving internally the module format (amd, esm).
     *
     * When running in a BEE, brequire and bimport are implemented by it, overriding both functions.
     *
     * @param resource {string} The resource identifier of the bundle
     * @param version {number} The version required by hmr to update a bundle's processor
     * @returns {Promise<*>}
     */
    function bimport(resource: string, version?: number): Promise<any>;
    namespace bimport {
        var mode: string;
        var resolve: (specifier: string, dependencies: any) => string;
    }
}

// FILE: bimport\brequire.d.ts
declare namespace ns_bimport_brequire {
    /**
     * Require a previously loaded bundle synchronously:
     * (can be a project bundle or library bundle, or an external bundle).
     *
     * brequire is implemented for internal use, as the require function available in the internal modules
     * exposes this functionality.
     * In fact the require of the internal modules internally makes use of brequire.
     *
     * When running in a BEE, brequire and bimport are implemented by it, overriding both functions.
     *
     * @param {string} specifier
     * @return {*}
     */
    function brequire(specifier: string): any;
}

// FILE: bimport\index.d.ts
declare namespace ns_bimport_index { }

// FILE: bimport\requirejs.d.ts
declare namespace ns_bimport_requirejs {
    interface Require {
        config: (config: any) => void;
        (modules: string[], ready: Function, errback?: Function): void;
        onError(err: any, errback?: (err: any) => void): void;
        undef(module: string): void;
    }
}

// FILE: bundle.d.ts
declare namespace ns_bundle {
    import Package = ns_package_index.Package;
    import Module = ns_module_index.Module;
    import IModuleSpecs = ns_module_index.IModuleSpecs;
    interface IBundleSpecs {
        module: IModuleSpecs;
        type: string;
        name?: string;
    }
    class Bundle extends Map<string, Package> {
        #private;
        get type(): string;
        get name(): string;
        get vspecifier(): string;
        get specifier(): string;
        get module(): Module;
        get uri(): string;
        constructor(specs: IBundleSpecs, uri?: string);
        package(language?: string): Package;
    }
}

// FILE: events\index.d.ts
declare namespace ns_events_index {
    import EventsSpecs = ns_events_types.EventsSpecs;
    import ListenerFunction = ns_events_types.ListenerFunction;
    import Trigger = ns_events_types.Trigger;
    class Events {
        #private;
        get destroyed(): boolean;
        constructor(specs?: EventsSpecs);
        /**
         * Binds an event handler to an event name
         *
         * @param {string} event
         * @param {ListenerFunction} listener
         * @param {number} priority
         * @returns {this}
         */
        on(event: string, listener: ListenerFunction, priority?: number): this;
        bind: (event: string, listener: ListenerFunction, priority?: number) => this;
        /**
         * Unbind an event listener
         *
         * @param {string} event
         * @param {ListenerFunction} listener
         * @param {number} force
         * @returns {this}
         */
        off(event: string, listener: ListenerFunction, force?: number): this;
        unbind: (event: string, listener: ListenerFunction, force?: number) => this;
        /**
         * Triggers an event
         *
         * @param {Trigger} event
         * @param {*} rest
         * @returns {Promise<*>}
         */
        trigger(event: Trigger, ...rest: any): any;
        destroy(): void;
    }
}

// FILE: events\types.d.ts
declare namespace ns_events_types {
    interface Inherited {
        bind: (event: string, listener: ListenerFunction, priority: number) => void;
        unbind: (event: string, Listener: ListenerFunction) => void;
    }
    interface EventsSpecs {
        supported?: [
            string
        ];
        bind?: Inherited;
    }
    type ListenerFunction = (...args: any) => void;
    interface ListenerSpecs {
        listener: ListenerFunction;
        priority: number;
    }
    interface TriggerSpecs {
        name: string;
        async?: boolean;
    }
    type Trigger = string | TriggerSpecs;
}

// FILE: instances.d.ts
declare namespace ns_instances {
    import Bundle = ns_bundle.Bundle;
    const instances: {
        register(bundle: Bundle): void;
        clear(): void;
        delete(key: any): boolean;
        forEach(callbackfn: (value: any, key: any, map: Map<any, any>) => void, thisArg?: any): void;
        get(key: any): any;
        has(key: any): boolean;
        set(key: any, value: any): any;
        readonly size: number;
        entries(): IterableIterator<[
            any,
            any
        ]>;
        keys(): IterableIterator<any>;
        values(): IterableIterator<any>;
        [Symbol.iterator](): IterableIterator<[
            any,
            any
        ]>;
        readonly [Symbol.toStringTag]: string;
    };
}

// FILE: module\index.d.ts
declare namespace ns_module_index {
    interface IModuleSpecs {
        vspecifier: string;
        multibundle?: boolean;
    }
    class Module {
        #private;
        get pkg(): string;
        get vspecifier(): string;
        get specifier(): string;
        get version(): string;
        get subpath(): string;
        get multibundle(): boolean;
        constructor(specs: IModuleSpecs);
        /**
         * @deprecated
         *
         * @param {string} action
         * @param {Record<string, *>} params
         * @return {Promise<*>}
         */
        execute(action: string, params: Record<string, any>): Promise<any>;
    }
}

// FILE: package\dependencies.d.ts
declare namespace ns_package_dependencies {
    import Package = ns_package_index.Package;
    class _default extends Map<string, any> {
        #private;
        constructor(pkg: Package);
        update(deps?: [
            string,
            any
        ][]): void;
    }
}

// FILE: package\exports.d.ts
declare namespace ns_package_exports {
    import Require = ns_package_ims_require_index.Require;
    /**
     * Interface is also required by @beyond-js/kernel/transversals
     */
    interface IExportsDescriptor {
        im: string;
        from: string;
        name: string;
    }
    class _default {
        #private;
        get values(): Record<string, any>;
        /**
         * Property is set by the bundle file, or by the transversal
         * @type {{im: string, from: string, name: string}[]}
         */
        descriptor: IExportsDescriptor[];
        /**
         * Property is set by the bundle file to process the module exports (es6, cjs, amd)
         * @type {(require: (id: string) => any) => {void(require)}}
         */
        process: (params: {
            require?: (id: string) => any;
            prop?: string;
            value?: string;
        }) => void;
        constructor(require: Require);
        set(key: string, value: string): void;
        update(): void;
    }
}

// FILE: package\ims\exports.d.ts
declare namespace ns_package_ims_exports {
    import PackageExports = ns_package_exports._default;
    import InternalModule = ns_package_ims_im.InternalModule;
    class IMExports {
        constructor(im: InternalModule, bexports: PackageExports);
    }
}

// FILE: package\ims\im.d.ts
declare namespace ns_package_ims_im {
    import Package = ns_package_index.Package;
    import Require = ns_package_ims_require_index.Require;
    import Trace = ns_package_ims_require_trace.Trace;
    type Exports = Record<string, any>;
    type IMWrapperFunction = (rq: (id: string) => any, exports: Exports, trace?: Trace) => void;
    type IMSpecs = {
        hash: number;
        creator: IMWrapperFunction;
    };
    class InternalModule {
        #private;
        get package(): Package;
        get id(): string;
        get hash(): number;
        get created(): boolean;
        require(trace: Trace, source: InternalModule): Exports;
        initialise(): void;
        update(creator: IMWrapperFunction, hash: number): void;
        constructor(pkg: Package, id: string, hash: number, creator: IMWrapperFunction, require: Require);
    }
}

// FILE: package\ims\index.d.ts
declare namespace ns_package_ims_index {
    import Package = ns_package_index.Package;
    import Require = ns_package_ims_require_index.Require;
    import Trace = ns_package_ims_require_trace.Trace;
    import InternalModule = ns_package_ims_im.InternalModule;
    import Exports = ns_package_ims_im.Exports;
    import IMSpecs = ns_package_ims_im.IMSpecs;
    type IMCreators = Map<string, IMSpecs>;
    class InternalModules {
        #private;
        constructor(pkg: Package);
        set _require(value: Require);
        register(ims: IMCreators): void;
        require(id: string, trace: Trace, source: InternalModule): Exports;
        initialise(): void;
        update(ims: IMCreators): void;
    }
}

// FILE: package\ims\require\index.d.ts
declare namespace ns_package_ims_require_index {
    import Package = ns_package_index.Package;
    import InternalModule = ns_package_ims_im.InternalModule;
    import Trace = ns_package_ims_require_trace.Trace;
    class Require {
        #private;
        get pkg(): Package;
        constructor(pkg: Package);
        /**
         * Solve a cjs require function
         *
         * @param {string} specifier The id of the internal module being required
         * @param {Trace} trace {object} The internal trace to find cyclical dependencies of internal modules
         * @param {InternalModule=} im The internal module that is making the call
         * @return {*}
         */
        solve(specifier: string, trace: Trace, im?: InternalModule): any;
    }
}

// FILE: package\ims\require\trace.d.ts
declare namespace ns_package_ims_require_trace {
    interface RequireTrace {
        source: string;
        id: string;
    }
    class Trace extends Array<RequireTrace> {
        has: (id: string) => RequireTrace;
        register(source: string, id: string): void;
    }
}

// FILE: package\index.d.ts
declare namespace ns_package_index {
    import Bundle = ns_bundle.Bundle;
    import IMCreators = ns_package_ims_index.IMCreators;
    import InternalModules = ns_package_ims_index.InternalModules;
    import Exports = ns_package_exports._default;
    import Dependencies = ns_package_dependencies._default;
    import Events = ns_events_index.Events;
    class Package {
        #private;
        get bundle(): Bundle;
        get language(): string;
        get vspecifier(): string;
        get specifier(): string;
        get ims(): InternalModules;
        get exports(): Exports;
        get dependencies(): Dependencies;
        get hmr(): Events;
        constructor(bundle: Bundle, language: string);
        get initialised(): boolean;
        initialise(ims?: IMCreators): void;
        update(ims: IMCreators): void;
    }
}

// FILE: package\instances.d.ts
declare namespace ns_package_instances {
    import Package = ns_package_index.Package;
    const _default: {
        register(pkg: Package): void;
        clear(): void;
        delete(key: any): boolean;
        forEach(callbackfn: (value: any, key: any, map: Map<any, any>) => void, thisArg?: any): void;
        get(key: any): any;
        has(key: any): boolean;
        set(key: any, value: any): any;
        readonly size: number;
        entries(): IterableIterator<[
            any,
            any
        ]>;
        keys(): IterableIterator<any>;
        values(): IterableIterator<any>;
        [Symbol.iterator](): IterableIterator<[
            any,
            any
        ]>;
        readonly [Symbol.toStringTag]: string;
    };
}

export import bimport = ns_bimport_bimport.bimport;
export import brequire = ns_bimport_brequire.brequire;
export import IBundleSpecs = ns_bundle.IBundleSpecs;
export import Bundle = ns_bundle.Bundle;
export import Events = ns_events_index.Events;
export import ListenerFunction = ns_events_types.ListenerFunction;
export import instances = ns_instances.instances;
export import Module = ns_module_index.Module;
export import IExportsDescriptor = ns_package_exports.IExportsDescriptor;
export import IMSpecs = ns_package_ims_im.IMSpecs;
export import IMCreators = ns_package_ims_index.IMCreators;
export import Package = ns_package_index.Package;


