/************
Processor: ts
************/

import * as dependency_0 from '@beyond-js/kernel/core';
import * as dependency_1 from '@beyond-js/widgets/render';

// FILE: attributes.d.ts
declare namespace ns_attributes {
    import Events = dependency_0.Events;
    class WidgetAttributes extends Map {
        #private;
        on: (event: string, listener: any) => Events;
        off: (event: string, listener: any) => Events;
        constructor(widget: HTMLElement);
        change(name: string, old: string, value: string): void;
    }
}

// FILE: client.d.ts
declare namespace ns_client {
    import WidgetControllerBase = ns_controller.WidgetControllerBase;
    import IWidgetStore = ns_controller.IWidgetStore;
    import WidgetAttributes = ns_attributes.WidgetAttributes;
    import StylesManager = dependency_1.StylesManager;
    /**
     * The client widget react controller
     */
    abstract class WidgetClientController extends WidgetControllerBase {
        #private;
        get widget(): HTMLElement;
        get store(): IWidgetStore;
        get attributes(): WidgetAttributes;
        attributeChanged(name: string, old: string, value: string): void;
        get styles(): StylesManager;
        protected constructor(widget: HTMLElement);
        abstract mount(props?: Record<string, any>): void;
        abstract unmount(): void;
        render(): void;
        refresh(): void;
        /**
         * Comes from the web component disconnectedCallback method call
         */
        disconnect(): void;
        initialise(): Promise<void>;
    }
}

// FILE: controller.d.ts
declare namespace ns_controller {
    import IWidgetSpecs = dependency_1.IWidgetSpecs;
    interface IWidgetStore {
        toJSON(): object;
        hydrate?(cached: object): Promise<void> | void;
        fetch(): Promise<void>;
    }
    abstract class WidgetControllerBase {
        #private;
        get specs(): IWidgetSpecs;
        get element(): string;
        get is(): string;
        get route(): string;
        get layout(): string;
        get pkg(): string;
        get Widget(): any;
        createStore(language?: string): IWidgetStore;
        /**
         * Controller base constructor
         *
         * @param {} specs
         * @param {HTMLElement} widget
         * The reason why it is declared as HTMLElement is to avoid circular reference between controller and widget.
         * @protected
         */
        protected constructor({ specs, widget }: {
            specs?: IWidgetSpecs;
            widget?: HTMLElement;
        });
    }
}

// FILE: ssr.d.ts
declare namespace ns_ssr {
    import WidgetControllerBase = ns_controller.WidgetControllerBase;
    import IWidgetSpecs = dependency_1.IWidgetSpecs;
    interface IWidgetRendered {
        html?: string;
        css?: string;
        errors?: string[];
        warnings?: string[];
        store?: object;
        attributes?: [
            string,
            string
        ][];
    }
    /**
     * The SSR widget react controller
     */
    abstract class WidgetServerController extends WidgetControllerBase {
        #private;
        get styles(): string[];
        protected constructor(params: {
            specs?: IWidgetSpecs;
            widget?: HTMLElement;
        });
        abstract render(props: Record<string, any>): Promise<IWidgetRendered> | IWidgetRendered;
    }
}

export import WidgetAttributes = ns_attributes.WidgetAttributes;
export import WidgetClientController = ns_client.WidgetClientController;
export import IWidgetStore = ns_controller.IWidgetStore;
export import WidgetControllerBase = ns_controller.WidgetControllerBase;
export import IWidgetRendered = ns_ssr.IWidgetRendered;
export import WidgetServerController = ns_ssr.WidgetServerController;


export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };