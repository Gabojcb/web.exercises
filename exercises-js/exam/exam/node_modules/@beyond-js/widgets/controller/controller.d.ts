/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from '@beyond-js/kernel/core';
import * as __beyond_dep_ns_1 from '@beyond-js/widgets/render';
// attributes.ts
declare namespace ns_0 {
  import Events = __beyond_dep_ns_0.Events;
  export class WidgetAttributes extends Map {
    #private;
    on: (event: string, listener: any) => Events;
    off: (event: string, listener: any) => Events;
    constructor(widget: HTMLElement);
    change(name: string, old: string, value: string): void;
  }
}


// client.ts
declare namespace ns_1 {
  import WidgetControllerBase = ns_2.WidgetControllerBase;
  import IWidgetStore = ns_2.IWidgetStore;
  import WidgetAttributes = ns_0.WidgetAttributes;
  import StylesManager = __beyond_dep_ns_1.StylesManager;
  /**
   * The client widget react controller
   */
  export abstract class WidgetClientController extends WidgetControllerBase {
    #private;
    get widget(): HTMLElement;
    get store(): IWidgetStore;
    get attributes(): WidgetAttributes;
    attributeChanged(name: string, old: string, value: string): void;
    get styles(): StylesManager;
    protected constructor(widget: HTMLElement);
    abstract mount(props?: Record<string, any>): void;
    abstract unmount(): void;
    render(): void;
    refresh(): void;
    /**
     * Comes from the web component disconnectedCallback method call
     */
    disconnect(): void;
    initialise(): Promise<void>;
  }
}


// controller.ts
declare namespace ns_2 {
  import IWidgetSpecs = __beyond_dep_ns_1.IWidgetSpecs;
  export interface IWidgetStore {
    toJSON(): object;
    hydrate?(cached: object): Promise<void> | void;
    fetch(): Promise<void>;
  }
  export abstract class WidgetControllerBase {
    #private;
    get specs(): IWidgetSpecs;
    get element(): string;
    get is(): string;
    get route(): string;
    get layout(): string;
    get pkg(): string;
    get Widget(): any;
    createStore(language?: string): IWidgetStore;
    /**
     * Controller base constructor
     *
     * @param {} specs
     * @param {HTMLElement} widget
     * The reason why it is declared as HTMLElement is to avoid circular reference between controller and widget.
     * @protected
     */
    protected constructor({
      specs,
      widget
    }: {
      specs?: IWidgetSpecs;
      widget?: HTMLElement;
    });
  }
}


// ssr.ts
declare namespace ns_3 {
  import WidgetControllerBase = ns_2.WidgetControllerBase;
  import IWidgetSpecs = __beyond_dep_ns_1.IWidgetSpecs;
  export interface IWidgetRendered {
    html?: string;
    css?: string;
    errors?: string[];
    warnings?: string[];
    store?: object;
    attributes?: [string, string][];
  }
  /**
   * The SSR widget react controller
   */
  export abstract class WidgetServerController extends WidgetControllerBase {
    #private;
    get styles(): string[];
    protected constructor(params: {
      specs?: IWidgetSpecs;
      widget?: HTMLElement;
    });
    abstract render(props: Record<string, any>): Promise<IWidgetRendered> | IWidgetRendered;
  }
}


export import WidgetAttributes = ns_0.WidgetAttributes;
export import WidgetClientController = ns_1.WidgetClientController;
export import IWidgetStore = ns_2.IWidgetStore;
export import WidgetControllerBase = ns_2.WidgetControllerBase;
export import IWidgetRendered = ns_3.IWidgetRendered;
export import WidgetServerController = ns_3.WidgetServerController;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };