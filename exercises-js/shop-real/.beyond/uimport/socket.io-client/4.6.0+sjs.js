{"code":"System.register([\"engine.io-parser@5.0.6\",\"@socket.io/component-emitter@3.1.0\",\"engine.io-client@6.4.0\",\"socket.io-parser@4.2.2\"], (_exports, _context) => {\n\nconst bimport = specifier => {\n\tconst dependencies = new Map([[\"engine.io-parser\",\"5.0.6\"],[\"@socket.io/component-emitter\",\"3.1.0\"],[\"engine.io-client\",\"6.4.0\"],[\"socket.io-client\",\"4.6.0\"],[\"socket.io-parser\",\"4.2.2\"]]);\n\treturn globalThis.bimport(globalThis.bimport.resolve(specifier, dependencies));\n};\n\n\nvar dependencies = new Map();\nvar require = dependency => dependencies.get(dependency);\nreturn {\nsetters: [dep => dependencies.set('engine.io-parser@5.0.6', dep), dep => dependencies.set('@socket.io/component-emitter@3.1.0', dep), dep => dependencies.set('engine.io-client@6.4.0', dep), dep => dependencies.set('socket.io-parser@4.2.2', dep)],\nexecute: function() {\n// Prevent esbuild from considering the context to be amd\nconst define = void 0;\nconst module = {};\n\nconst code = (module, require) => {\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// .beyond/uimport/socket.io-client.4.6.0.js\nvar socket_io_client_4_6_0_exports = {};\n__export(socket_io_client_4_6_0_exports, {\n  Manager: () => Manager,\n  Socket: () => Socket,\n  connect: () => lookup,\n  default: () => socket_io_client_4_6_0_default,\n  io: () => lookup,\n  protocol: () => import_socket4.protocol\n});\nmodule.exports = __toCommonJS(socket_io_client_4_6_0_exports);\n\n// node_modules/socket.io-client/build/esm/url.js\nvar import_engine = require(\"engine.io-client@6.4.0\");\nfunction url(uri, path = \"\", loc) {\n  let obj = uri;\n  loc = loc || typeof location !== \"undefined\" && location;\n  if (null == uri) uri = loc.protocol + \"//\" + loc.host;\n  if (typeof uri === \"string\") {\n    if (\"/\" === uri.charAt(0)) {\n      if (\"/\" === uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.host + uri;\n      }\n    }\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      if (\"undefined\" !== typeof loc) {\n        uri = loc.protocol + \"//\" + uri;\n      } else {\n        uri = \"https://\" + uri;\n      }\n    }\n    obj = (0, import_engine.parse)(uri);\n  }\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = \"80\";\n    } else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = \"443\";\n    }\n  }\n  obj.path = obj.path || \"/\";\n  const ipv6 = obj.host.indexOf(\":\") !== -1;\n  const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n  obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n  obj.href = obj.protocol + \"://\" + host + (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n  return obj;\n}\n\n// node_modules/socket.io-client/build/esm/on.js\nfunction on(obj, ev, fn) {\n  obj.on(ev, fn);\n  return function subDestroy() {\n    obj.off(ev, fn);\n  };\n}\n\n// node_modules/socket.io-client/build/esm/socket.js\nvar import_socket = require(\"socket.io-parser@4.2.2\");\nvar import_component_emitter = require(\"@socket.io/component-emitter@3.1.0\");\nvar RESERVED_EVENTS = Object.freeze({\n  connect: 1,\n  connect_error: 1,\n  disconnect: 1,\n  disconnecting: 1,\n  newListener: 1,\n  removeListener: 1\n});\nvar Socket = class extends import_component_emitter.Emitter {\n  constructor(io, nsp, opts) {\n    super();\n    this.connected = false;\n    this.recovered = false;\n    this.receiveBuffer = [];\n    this.sendBuffer = [];\n    this._queue = [];\n    this.ids = 0;\n    this.acks = {};\n    this.flags = {};\n    this.io = io;\n    this.nsp = nsp;\n    if (opts && opts.auth) {\n      this.auth = opts.auth;\n    }\n    this._opts = Object.assign({}, opts);\n    if (this.io._autoConnect) this.open();\n  }\n  get disconnected() {\n    return !this.connected;\n  }\n  subEvents() {\n    if (this.subs) return;\n    const io = this.io;\n    this.subs = [on(io, \"open\", this.onopen.bind(this)), on(io, \"packet\", this.onpacket.bind(this)), on(io, \"error\", this.onerror.bind(this)), on(io, \"close\", this.onclose.bind(this))];\n  }\n  get active() {\n    return !!this.subs;\n  }\n  connect() {\n    if (this.connected) return this;\n    this.subEvents();\n    if (!this.io[\"_reconnecting\"]) this.io.open();\n    if (\"open\" === this.io._readyState) this.onopen();\n    return this;\n  }\n  open() {\n    return this.connect();\n  }\n  send(...args) {\n    args.unshift(\"message\");\n    this.emit.apply(this, args);\n    return this;\n  }\n  emit(ev, ...args) {\n    if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n      throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n    }\n    args.unshift(ev);\n    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n      this._addToQueue(args);\n      return this;\n    }\n    const packet = {\n      type: import_socket.PacketType.EVENT,\n      data: args\n    };\n    packet.options = {};\n    packet.options.compress = this.flags.compress !== false;\n    if (\"function\" === typeof args[args.length - 1]) {\n      const id = this.ids++;\n      const ack = args.pop();\n      this._registerAckCallback(id, ack);\n      packet.id = id;\n    }\n    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n    if (discardPacket) {} else if (this.connected) {\n      this.notifyOutgoingListeners(packet);\n      this.packet(packet);\n    } else {\n      this.sendBuffer.push(packet);\n    }\n    this.flags = {};\n    return this;\n  }\n  _registerAckCallback(id, ack) {\n    var _a;\n    const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n    if (timeout === void 0) {\n      this.acks[id] = ack;\n      return;\n    }\n    const timer = this.io.setTimeoutFn(() => {\n      delete this.acks[id];\n      for (let i = 0; i < this.sendBuffer.length; i++) {\n        if (this.sendBuffer[i].id === id) {\n          this.sendBuffer.splice(i, 1);\n        }\n      }\n      ack.call(this, new Error(\"operation has timed out\"));\n    }, timeout);\n    this.acks[id] = (...args) => {\n      this.io.clearTimeoutFn(timer);\n      ack.apply(this, [null, ...args]);\n    };\n  }\n  emitWithAck(ev, ...args) {\n    const withErr = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;\n    return new Promise((resolve, reject) => {\n      args.push((arg1, arg2) => {\n        if (withErr) {\n          return arg1 ? reject(arg1) : resolve(arg2);\n        } else {\n          return resolve(arg1);\n        }\n      });\n      this.emit(ev, ...args);\n    });\n  }\n  _addToQueue(args) {\n    let ack;\n    if (typeof args[args.length - 1] === \"function\") {\n      ack = args.pop();\n    }\n    const packet = {\n      id: this.ids++,\n      tryCount: 0,\n      pending: false,\n      args,\n      flags: Object.assign({\n        fromQueue: true\n      }, this.flags)\n    };\n    args.push((err, ...responseArgs) => {\n      if (packet !== this._queue[0]) {\n        return;\n      }\n      const hasError = err !== null;\n      if (hasError) {\n        if (packet.tryCount > this._opts.retries) {\n          this._queue.shift();\n          if (ack) {\n            ack(err);\n          }\n        }\n      } else {\n        this._queue.shift();\n        if (ack) {\n          ack(null, ...responseArgs);\n        }\n      }\n      packet.pending = false;\n      return this._drainQueue();\n    });\n    this._queue.push(packet);\n    this._drainQueue();\n  }\n  _drainQueue() {\n    if (this._queue.length === 0) {\n      return;\n    }\n    const packet = this._queue[0];\n    if (packet.pending) {\n      return;\n    }\n    packet.pending = true;\n    packet.tryCount++;\n    const currentId = this.ids;\n    this.ids = packet.id;\n    this.flags = packet.flags;\n    this.emit.apply(this, packet.args);\n    this.ids = currentId;\n  }\n  packet(packet) {\n    packet.nsp = this.nsp;\n    this.io._packet(packet);\n  }\n  onopen() {\n    if (typeof this.auth == \"function\") {\n      this.auth(data => {\n        this._sendConnectPacket(data);\n      });\n    } else {\n      this._sendConnectPacket(this.auth);\n    }\n  }\n  _sendConnectPacket(data) {\n    this.packet({\n      type: import_socket.PacketType.CONNECT,\n      data: this._pid ? Object.assign({\n        pid: this._pid,\n        offset: this._lastOffset\n      }, data) : data\n    });\n  }\n  onerror(err) {\n    if (!this.connected) {\n      this.emitReserved(\"connect_error\", err);\n    }\n  }\n  onclose(reason, description) {\n    this.connected = false;\n    delete this.id;\n    this.emitReserved(\"disconnect\", reason, description);\n  }\n  onpacket(packet) {\n    const sameNamespace = packet.nsp === this.nsp;\n    if (!sameNamespace) return;\n    switch (packet.type) {\n      case import_socket.PacketType.CONNECT:\n        if (packet.data && packet.data.sid) {\n          this.onconnect(packet.data.sid, packet.data.pid);\n        } else {\n          this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n        }\n        break;\n      case import_socket.PacketType.EVENT:\n      case import_socket.PacketType.BINARY_EVENT:\n        this.onevent(packet);\n        break;\n      case import_socket.PacketType.ACK:\n      case import_socket.PacketType.BINARY_ACK:\n        this.onack(packet);\n        break;\n      case import_socket.PacketType.DISCONNECT:\n        this.ondisconnect();\n        break;\n      case import_socket.PacketType.CONNECT_ERROR:\n        this.destroy();\n        const err = new Error(packet.data.message);\n        err.data = packet.data.data;\n        this.emitReserved(\"connect_error\", err);\n        break;\n    }\n  }\n  onevent(packet) {\n    const args = packet.data || [];\n    if (null != packet.id) {\n      args.push(this.ack(packet.id));\n    }\n    if (this.connected) {\n      this.emitEvent(args);\n    } else {\n      this.receiveBuffer.push(Object.freeze(args));\n    }\n  }\n  emitEvent(args) {\n    if (this._anyListeners && this._anyListeners.length) {\n      const listeners = this._anyListeners.slice();\n      for (const listener of listeners) {\n        listener.apply(this, args);\n      }\n    }\n    super.emit.apply(this, args);\n    if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n      this._lastOffset = args[args.length - 1];\n    }\n  }\n  ack(id) {\n    const self = this;\n    let sent = false;\n    return function (...args) {\n      if (sent) return;\n      sent = true;\n      self.packet({\n        type: import_socket.PacketType.ACK,\n        id,\n        data: args\n      });\n    };\n  }\n  onack(packet) {\n    const ack = this.acks[packet.id];\n    if (\"function\" === typeof ack) {\n      ack.apply(this, packet.data);\n      delete this.acks[packet.id];\n    } else {}\n  }\n  onconnect(id, pid) {\n    this.id = id;\n    this.recovered = pid && this._pid === pid;\n    this._pid = pid;\n    this.connected = true;\n    this.emitBuffered();\n    this.emitReserved(\"connect\");\n  }\n  emitBuffered() {\n    this.receiveBuffer.forEach(args => this.emitEvent(args));\n    this.receiveBuffer = [];\n    this.sendBuffer.forEach(packet => {\n      this.notifyOutgoingListeners(packet);\n      this.packet(packet);\n    });\n    this.sendBuffer = [];\n  }\n  ondisconnect() {\n    this.destroy();\n    this.onclose(\"io server disconnect\");\n  }\n  destroy() {\n    if (this.subs) {\n      this.subs.forEach(subDestroy => subDestroy());\n      this.subs = void 0;\n    }\n    this.io[\"_destroy\"](this);\n  }\n  disconnect() {\n    if (this.connected) {\n      this.packet({\n        type: import_socket.PacketType.DISCONNECT\n      });\n    }\n    this.destroy();\n    if (this.connected) {\n      this.onclose(\"io client disconnect\");\n    }\n    return this;\n  }\n  close() {\n    return this.disconnect();\n  }\n  compress(compress) {\n    this.flags.compress = compress;\n    return this;\n  }\n  get volatile() {\n    this.flags.volatile = true;\n    return this;\n  }\n  timeout(timeout) {\n    this.flags.timeout = timeout;\n    return this;\n  }\n  onAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n    this._anyListeners.push(listener);\n    return this;\n  }\n  prependAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n    this._anyListeners.unshift(listener);\n    return this;\n  }\n  offAny(listener) {\n    if (!this._anyListeners) {\n      return this;\n    }\n    if (listener) {\n      const listeners = this._anyListeners;\n      for (let i = 0; i < listeners.length; i++) {\n        if (listener === listeners[i]) {\n          listeners.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._anyListeners = [];\n    }\n    return this;\n  }\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n  onAnyOutgoing(listener) {\n    this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n    this._anyOutgoingListeners.push(listener);\n    return this;\n  }\n  prependAnyOutgoing(listener) {\n    this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n    this._anyOutgoingListeners.unshift(listener);\n    return this;\n  }\n  offAnyOutgoing(listener) {\n    if (!this._anyOutgoingListeners) {\n      return this;\n    }\n    if (listener) {\n      const listeners = this._anyOutgoingListeners;\n      for (let i = 0; i < listeners.length; i++) {\n        if (listener === listeners[i]) {\n          listeners.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._anyOutgoingListeners = [];\n    }\n    return this;\n  }\n  listenersAnyOutgoing() {\n    return this._anyOutgoingListeners || [];\n  }\n  notifyOutgoingListeners(packet) {\n    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n      const listeners = this._anyOutgoingListeners.slice();\n      for (const listener of listeners) {\n        listener.apply(this, packet.data);\n      }\n    }\n  }\n};\n\n// node_modules/socket.io-client/build/esm/contrib/backo2.js\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 1e4;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\nBackoff.prototype.duration = function () {\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand = Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\nBackoff.prototype.reset = function () {\n  this.attempts = 0;\n};\nBackoff.prototype.setMin = function (min) {\n  this.ms = min;\n};\nBackoff.prototype.setMax = function (max) {\n  this.max = max;\n};\nBackoff.prototype.setJitter = function (jitter) {\n  this.jitter = jitter;\n};\n\n// node_modules/socket.io-client/build/esm/manager.js\nvar import_engine2 = require(\"engine.io-client@6.4.0\");\nvar parser = __toESM(require(\"socket.io-parser@4.2.2\"), 0);\nvar import_component_emitter2 = require(\"@socket.io/component-emitter@3.1.0\");\nvar Manager = class extends import_component_emitter2.Emitter {\n  constructor(uri, opts) {\n    var _a;\n    super();\n    this.nsps = {};\n    this.subs = [];\n    if (uri && \"object\" === typeof uri) {\n      opts = uri;\n      uri = void 0;\n    }\n    opts = opts || {};\n    opts.path = opts.path || \"/socket.io\";\n    this.opts = opts;\n    (0, import_engine2.installTimerFunctions)(this, opts);\n    this.reconnection(opts.reconnection !== false);\n    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n    this.reconnectionDelay(opts.reconnectionDelay || 1e3);\n    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);\n    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n    this.backoff = new Backoff({\n      min: this.reconnectionDelay(),\n      max: this.reconnectionDelayMax(),\n      jitter: this.randomizationFactor()\n    });\n    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);\n    this._readyState = \"closed\";\n    this.uri = uri;\n    const _parser = opts.parser || parser;\n    this.encoder = new _parser.Encoder();\n    this.decoder = new _parser.Decoder();\n    this._autoConnect = opts.autoConnect !== false;\n    if (this._autoConnect) this.open();\n  }\n  reconnection(v) {\n    if (!arguments.length) return this._reconnection;\n    this._reconnection = !!v;\n    return this;\n  }\n  reconnectionAttempts(v) {\n    if (v === void 0) return this._reconnectionAttempts;\n    this._reconnectionAttempts = v;\n    return this;\n  }\n  reconnectionDelay(v) {\n    var _a;\n    if (v === void 0) return this._reconnectionDelay;\n    this._reconnectionDelay = v;\n    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n    return this;\n  }\n  randomizationFactor(v) {\n    var _a;\n    if (v === void 0) return this._randomizationFactor;\n    this._randomizationFactor = v;\n    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n    return this;\n  }\n  reconnectionDelayMax(v) {\n    var _a;\n    if (v === void 0) return this._reconnectionDelayMax;\n    this._reconnectionDelayMax = v;\n    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n    return this;\n  }\n  timeout(v) {\n    if (!arguments.length) return this._timeout;\n    this._timeout = v;\n    return this;\n  }\n  maybeReconnectOnOpen() {\n    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {\n      this.reconnect();\n    }\n  }\n  open(fn) {\n    if (~this._readyState.indexOf(\"open\")) return this;\n    this.engine = new import_engine2.Socket(this.uri, this.opts);\n    const socket = this.engine;\n    const self = this;\n    this._readyState = \"opening\";\n    this.skipReconnect = false;\n    const openSubDestroy = on(socket, \"open\", function () {\n      self.onopen();\n      fn && fn();\n    });\n    const errorSub = on(socket, \"error\", err => {\n      self.cleanup();\n      self._readyState = \"closed\";\n      this.emitReserved(\"error\", err);\n      if (fn) {\n        fn(err);\n      } else {\n        self.maybeReconnectOnOpen();\n      }\n    });\n    if (false !== this._timeout) {\n      const timeout = this._timeout;\n      if (timeout === 0) {\n        openSubDestroy();\n      }\n      const timer = this.setTimeoutFn(() => {\n        openSubDestroy();\n        socket.close();\n        socket.emit(\"error\", new Error(\"timeout\"));\n      }, timeout);\n      if (this.opts.autoUnref) {\n        timer.unref();\n      }\n      this.subs.push(function subDestroy() {\n        clearTimeout(timer);\n      });\n    }\n    this.subs.push(openSubDestroy);\n    this.subs.push(errorSub);\n    return this;\n  }\n  connect(fn) {\n    return this.open(fn);\n  }\n  onopen() {\n    this.cleanup();\n    this._readyState = \"open\";\n    this.emitReserved(\"open\");\n    const socket = this.engine;\n    this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n  }\n  onping() {\n    this.emitReserved(\"ping\");\n  }\n  ondata(data) {\n    try {\n      this.decoder.add(data);\n    } catch (e) {\n      this.onclose(\"parse error\", e);\n    }\n  }\n  ondecoded(packet) {\n    (0, import_engine2.nextTick)(() => {\n      this.emitReserved(\"packet\", packet);\n    }, this.setTimeoutFn);\n  }\n  onerror(err) {\n    this.emitReserved(\"error\", err);\n  }\n  socket(nsp, opts) {\n    let socket = this.nsps[nsp];\n    if (!socket) {\n      socket = new Socket(this, nsp, opts);\n      this.nsps[nsp] = socket;\n    }\n    if (this._autoConnect) {\n      socket.connect();\n    }\n    return socket;\n  }\n  _destroy(socket) {\n    const nsps = Object.keys(this.nsps);\n    for (const nsp of nsps) {\n      const socket2 = this.nsps[nsp];\n      if (socket2.active) {\n        return;\n      }\n    }\n    this._close();\n  }\n  _packet(packet) {\n    const encodedPackets = this.encoder.encode(packet);\n    for (let i = 0; i < encodedPackets.length; i++) {\n      this.engine.write(encodedPackets[i], packet.options);\n    }\n  }\n  cleanup() {\n    this.subs.forEach(subDestroy => subDestroy());\n    this.subs.length = 0;\n    this.decoder.destroy();\n  }\n  _close() {\n    this.skipReconnect = true;\n    this._reconnecting = false;\n    this.onclose(\"forced close\");\n    if (this.engine) this.engine.close();\n  }\n  disconnect() {\n    return this._close();\n  }\n  onclose(reason, description) {\n    this.cleanup();\n    this.backoff.reset();\n    this._readyState = \"closed\";\n    this.emitReserved(\"close\", reason, description);\n    if (this._reconnection && !this.skipReconnect) {\n      this.reconnect();\n    }\n  }\n  reconnect() {\n    if (this._reconnecting || this.skipReconnect) return this;\n    const self = this;\n    if (this.backoff.attempts >= this._reconnectionAttempts) {\n      this.backoff.reset();\n      this.emitReserved(\"reconnect_failed\");\n      this._reconnecting = false;\n    } else {\n      const delay = this.backoff.duration();\n      this._reconnecting = true;\n      const timer = this.setTimeoutFn(() => {\n        if (self.skipReconnect) return;\n        this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n        if (self.skipReconnect) return;\n        self.open(err => {\n          if (err) {\n            self._reconnecting = false;\n            self.reconnect();\n            this.emitReserved(\"reconnect_error\", err);\n          } else {\n            self.onreconnect();\n          }\n        });\n      }, delay);\n      if (this.opts.autoUnref) {\n        timer.unref();\n      }\n      this.subs.push(function subDestroy() {\n        clearTimeout(timer);\n      });\n    }\n  }\n  onreconnect() {\n    const attempt = this.backoff.attempts;\n    this._reconnecting = false;\n    this.backoff.reset();\n    this.emitReserved(\"reconnect\", attempt);\n  }\n};\n\n// node_modules/socket.io-client/build/esm/index.js\nvar import_socket4 = require(\"socket.io-parser@4.2.2\");\nvar cache = {};\nfunction lookup(uri, opts) {\n  if (typeof uri === \"object\") {\n    opts = uri;\n    uri = void 0;\n  }\n  opts = opts || {};\n  const parsed = url(uri, opts.path || \"/socket.io\");\n  const source = parsed.source;\n  const id = parsed.id;\n  const path = parsed.path;\n  const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n  const newConnection = opts.forceNew || opts[\"force new connection\"] || false === opts.multiplex || sameNamespace;\n  let io;\n  if (newConnection) {\n    io = new Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      cache[id] = new Manager(source, opts);\n    }\n    io = cache[id];\n  }\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.queryKey;\n  }\n  return io.socket(parsed.path, opts);\n}\nObject.assign(lookup, {\n  Manager,\n  Socket,\n  io: lookup,\n  connect: lookup\n});\n\n// .beyond/uimport/socket.io-client.4.6.0.js\nvar socket_io_client_4_6_0_default = lookup;\n};\n\ncode(module, require);\n_exports(module.exports);\n}}});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy5iZXlvbmQvdWltcG9ydC9zb2NrZXQuaW8tY2xpZW50LjQuNi4wLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvZXNtL3VybC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2VzbS9vbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2VzbS9zb2NrZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9idWlsZC9lc20vY29udHJpYi9iYWNrbzIuanMiLCIuLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9idWlsZC9lc20vbWFuYWdlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2VzbS9pbmRleC5qcyJdLCJuYW1lcyI6WyJfX2V4cG9ydCIsIk1hbmFnZXIiLCJTb2NrZXQiLCJjb25uZWN0IiwiZGVmYXVsdCIsImlvIiwicHJvdG9jb2wiLCJtb2R1bGUiLCJyZXF1aXJlIiwidXJsIiwidXJpIiwicGF0aCIsImxvYyIsIm9iaiIsImxvY2F0aW9uIiwiaG9zdCIsImNoYXJBdCIsInRlc3QiLCJpbXBvcnRfZW5naW5lIiwicG9ydCIsImlwdjYiLCJpbmRleE9mIiwiaWQiLCJocmVmIiwib24iLCJldiIsImZuIiwic3ViRGVzdHJveSIsIm9mZiIsIlJFU0VSVkVEX0VWRU5UUyIsIk9iamVjdCIsImZyZWV6ZSIsImNvbm5lY3RfZXJyb3IiLCJkaXNjb25uZWN0IiwiZGlzY29ubmVjdGluZyIsIm5ld0xpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJpbXBvcnRfY29tcG9uZW50X2VtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsIm5zcCIsIm9wdHMiLCJjb25uZWN0ZWQiLCJyZWNvdmVyZWQiLCJyZWNlaXZlQnVmZmVyIiwic2VuZEJ1ZmZlciIsIl9xdWV1ZSIsImlkcyIsImFja3MiLCJmbGFncyIsImF1dGgiLCJfb3B0cyIsImFzc2lnbiIsIl9hdXRvQ29ubmVjdCIsIm9wZW4iLCJkaXNjb25uZWN0ZWQiLCJzdWJFdmVudHMiLCJzdWJzIiwib25vcGVuIiwiYmluZCIsIm9ucGFja2V0Iiwib25lcnJvciIsIm9uY2xvc2UiLCJhY3RpdmUiLCJfcmVhZHlTdGF0ZSIsInNlbmQiLCJhcmdzIiwidW5zaGlmdCIsImVtaXQiLCJhcHBseSIsImhhc093blByb3BlcnR5IiwiRXJyb3IiLCJ0b1N0cmluZyIsInJldHJpZXMiLCJmcm9tUXVldWUiLCJ2b2xhdGlsZSIsIl9hZGRUb1F1ZXVlIiwicGFja2V0IiwidHlwZSIsImltcG9ydF9zb2NrZXQiLCJFVkVOVCIsImRhdGEiLCJvcHRpb25zIiwiY29tcHJlc3MiLCJsZW5ndGgiLCJhY2siLCJwb3AiLCJfcmVnaXN0ZXJBY2tDYWxsYmFjayIsImlzVHJhbnNwb3J0V3JpdGFibGUiLCJlbmdpbmUiLCJ0cmFuc3BvcnQiLCJ3cml0YWJsZSIsImRpc2NhcmRQYWNrZXQiLCJub3RpZnlPdXRnb2luZ0xpc3RlbmVycyIsInB1c2giLCJfYSIsInRpbWVvdXQiLCJhY2tUaW1lb3V0IiwidGltZXIiLCJzZXRUaW1lb3V0Rm4iLCJpIiwic3BsaWNlIiwiY2FsbCIsImNsZWFyVGltZW91dEZuIiwiZW1pdFdpdGhBY2siLCJ3aXRoRXJyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJhcmcxIiwiYXJnMiIsInRyeUNvdW50IiwicGVuZGluZyIsImVyciIsInJlc3BvbnNlQXJncyIsImhhc0Vycm9yIiwic2hpZnQiLCJfZHJhaW5RdWV1ZSIsImN1cnJlbnRJZCIsIl9wYWNrZXQiLCJfc2VuZENvbm5lY3RQYWNrZXQiLCJDT05ORUNUIiwiX3BpZCIsInBpZCIsIm9mZnNldCIsIl9sYXN0T2Zmc2V0IiwiZW1pdFJlc2VydmVkIiwicmVhc29uIiwiZGVzY3JpcHRpb24iLCJzYW1lTmFtZXNwYWNlIiwic2lkIiwib25jb25uZWN0IiwiQklOQVJZX0VWRU5UIiwib25ldmVudCIsIkFDSyIsIkJJTkFSWV9BQ0siLCJvbmFjayIsIkRJU0NPTk5FQ1QiLCJvbmRpc2Nvbm5lY3QiLCJDT05ORUNUX0VSUk9SIiwiZGVzdHJveSIsIm1lc3NhZ2UiLCJlbWl0RXZlbnQiLCJfYW55TGlzdGVuZXJzIiwibGlzdGVuZXJzIiwic2xpY2UiLCJsaXN0ZW5lciIsInNlbGYiLCJzZW50IiwiZW1pdEJ1ZmZlcmVkIiwiZm9yRWFjaCIsImNsb3NlIiwib25BbnkiLCJwcmVwZW5kQW55Iiwib2ZmQW55IiwibGlzdGVuZXJzQW55Iiwib25BbnlPdXRnb2luZyIsIl9hbnlPdXRnb2luZ0xpc3RlbmVycyIsInByZXBlbmRBbnlPdXRnb2luZyIsIm9mZkFueU91dGdvaW5nIiwibGlzdGVuZXJzQW55T3V0Z29pbmciLCJCYWNrb2ZmIiwibXMiLCJtaW4iLCJtYXgiLCJmYWN0b3IiLCJqaXR0ZXIiLCJhdHRlbXB0cyIsInByb3RvdHlwZSIsImR1cmF0aW9uIiwiTWF0aCIsInBvdyIsInJhbmQiLCJyYW5kb20iLCJkZXZpYXRpb24iLCJmbG9vciIsInJlc2V0Iiwic2V0TWluIiwic2V0TWF4Iiwic2V0Sml0dGVyIiwiX190b0VTTSIsImltcG9ydF9jb21wb25lbnRfZW1pdHRlcjIiLCJuc3BzIiwicmVjb25uZWN0aW9uIiwicmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJJbmZpbml0eSIsInJlY29ubmVjdGlvbkRlbGF5IiwicmVjb25uZWN0aW9uRGVsYXlNYXgiLCJyYW5kb21pemF0aW9uRmFjdG9yIiwiYmFja29mZiIsIl9wYXJzZXIiLCJwYXJzZXIiLCJlbmNvZGVyIiwiRW5jb2RlciIsImRlY29kZXIiLCJEZWNvZGVyIiwiYXV0b0Nvbm5lY3QiLCJ2IiwiYXJndW1lbnRzIiwiX3JlY29ubmVjdGlvbiIsIl9yZWNvbm5lY3Rpb25BdHRlbXB0cyIsIl9yZWNvbm5lY3Rpb25EZWxheSIsIl9yYW5kb21pemF0aW9uRmFjdG9yIiwiX3JlY29ubmVjdGlvbkRlbGF5TWF4IiwiX3RpbWVvdXQiLCJtYXliZVJlY29ubmVjdE9uT3BlbiIsIl9yZWNvbm5lY3RpbmciLCJyZWNvbm5lY3QiLCJpbXBvcnRfZW5naW5lMiIsInNvY2tldCIsInNraXBSZWNvbm5lY3QiLCJvcGVuU3ViRGVzdHJveSIsImVycm9yU3ViIiwiY2xlYW51cCIsImF1dG9VbnJlZiIsInVucmVmIiwiY2xlYXJUaW1lb3V0Iiwib25waW5nIiwib25kYXRhIiwib25kZWNvZGVkIiwiYWRkIiwiZSIsIl9kZXN0cm95Iiwia2V5cyIsIl9jbG9zZSIsImVuY29kZWRQYWNrZXRzIiwiZW5jb2RlIiwid3JpdGUiLCJkZWxheSIsIm9ucmVjb25uZWN0IiwiYXR0ZW1wdCIsImNhY2hlIiwibG9va3VwIiwicGFyc2VkIiwic291cmNlIiwibmV3Q29ubmVjdGlvbiIsImZvcmNlTmV3IiwibXVsdGlwbGV4IiwicXVlcnkiLCJxdWVyeUtleSIsInNvY2tldF9pb19jbGllbnRfNF82XzBfZGVmYXVsdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQUE7RUFBQUM7RUFBQUM7RUFBQUM7RUFBQUM7RUFBQUM7RUFBQUM7QUFBQTtBQUFBQzs7O0FDQUEsb0JBQXNCQztBQVVmLFNBQVNDLElBQUlDLEtBQUtDLE9BQU8sSUFBSUMsS0FBSztFQUNyQyxJQUFJQyxNQUFNSDtFQUVWRSxNQUFNQSxPQUFRLE9BQU9FLGFBQWEsZUFBZUE7RUFDakQsSUFBSSxRQUFRSixLQUNSQSxNQUFNRSxJQUFJTixXQUFXLE9BQU9NLElBQUlHO0VBRXBDLElBQUksT0FBT0wsUUFBUSxVQUFVO0lBQ3pCLElBQUksUUFBUUEsSUFBSU0sT0FBTyxDQUFDLEdBQUc7TUFDdkIsSUFBSSxRQUFRTixJQUFJTSxPQUFPLENBQUMsR0FBRztRQUN2Qk4sTUFBTUUsSUFBSU4sV0FBV0k7TUFDekIsT0FDSztRQUNEQSxNQUFNRSxJQUFJRyxPQUFPTDtNQUNyQjtJQUNKO0lBQ0EsSUFBSSxDQUFDLHNCQUFzQk8sS0FBS1AsR0FBRyxHQUFH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","dependencies":[{"id":"engine.io-parser@5.0.6","path":"C:\\Users\\Gabigol\\Documents\\shop-real\\project\\node_modules\\engine.io-parser"},{"id":"@socket.io/component-emitter@3.1.0","path":"C:\\Users\\Gabigol\\Documents\\shop-real\\project\\node_modules\\@socket.io\\component-emitter"},{"id":"engine.io-client@6.4.0","path":"C:\\Users\\Gabigol\\Documents\\shop-real\\project\\node_modules\\engine.io-client"},{"id":"socket.io-parser@4.2.2","path":"C:\\Users\\Gabigol\\Documents\\shop-real\\project\\node_modules\\socket.io-parser"}],"warnings":[]}