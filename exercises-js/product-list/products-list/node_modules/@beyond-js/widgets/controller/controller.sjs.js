System.register(["@beyond-js/kernel/bundle", "@beyond-js/kernel/core", "@beyond-js/widgets/render", "@beyond-js/kernel/styles"], function (_export, _context) {
  "use strict";

  var dependency_0, dependency_1, dependency_2, dependency_3, __Bundle, __pkg, ims, WidgetAttributes, WidgetClientController, IWidgetStore, WidgetControllerBase, IWidgetRendered, WidgetServerController, __beyond_pkg, hmr;
  _export({
    WidgetAttributes: void 0,
    WidgetClientController: void 0,
    IWidgetStore: void 0,
    WidgetControllerBase: void 0,
    IWidgetRendered: void 0,
    WidgetServerController: void 0
  });
  return {
    setters: [function (_beyondJsKernelBundle) {
      dependency_0 = _beyondJsKernelBundle;
    }, function (_beyondJsKernelCore) {
      dependency_1 = _beyondJsKernelCore;
    }, function (_beyondJsWidgetsRender) {
      dependency_2 = _beyondJsWidgetsRender;
    }, function (_beyondJsKernelStyles) {
      dependency_3 = _beyondJsKernelStyles;
    }],
    execute: function () {
      ({
        Bundle: __Bundle
      } = dependency_0);
      __pkg = new __Bundle({
        "module": {
          "vspecifier": "@beyond-js/widgets@0.1.4/controller"
        },
        "type": "ts"
      }, _context.meta.url).package();
      ;
      __pkg.dependencies.update([['@beyond-js/kernel/core', dependency_1], ['@beyond-js/widgets/render', dependency_2], ['@beyond-js/kernel/styles', dependency_3]]);
      ims = new Map();
      /****************************
      INTERNAL MODULE: ./attributes
      ****************************/
      ims.set('./attributes', {
        hash: 3176328789,
        creator: function (require, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WidgetAttributes = void 0;
          var _core = require("@beyond-js/kernel/core");
          /*bundle*/
          class WidgetAttributes extends Map {
            // The reason why it is declared as HTMLElement is to avoid circular reference between controller and widget.
            #widget;
            #events = new _core.Events();
            on = (event, listener) => this.#events.on(event, listener);
            off = (event, listener) => this.#events.off(event, listener);
            constructor(widget) {
              super();
              this.#widget = widget;
              let attrs = widget.specs.attrs;
              attrs?.forEach(attr => this.set(attr, widget.getAttribute(attr)));
            }
            change(name, old, value) {
              this.set(name, value);
              this.#events.trigger('change');
              this.#events.trigger(`${name}:change`, value);
            }
          }
          exports.WidgetAttributes = WidgetAttributes;
        }
      });

      /************************
      INTERNAL MODULE: ./client
      ************************/

      ims.set('./client', {
        hash: 2102509577,
        creator: function (require, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WidgetClientController = void 0;
          var _controller = require("./controller");
          var _attributes = require("./attributes");
          var _bundle = require("@beyond-js/kernel/bundle");
          var _styles = require("@beyond-js/kernel/styles");
          /*bundle*/ /**
                      * The client widget react controller
                      */
          class WidgetClientController extends _controller.WidgetControllerBase {
            /**
             * The beyond widget.
             * The reason why it is declared as HTMLElement is to avoid circular reference between controller and widget.
             *
             * @type {HTMLElement} The beyond widget
             * @private
             */
            #widget;
            get widget() {
              return this.#widget;
            }
            #store;
            get store() {
              return this.#store;
            }
            #attributes;
            get attributes() {
              return this.#attributes;
            }
            attributeChanged(name, old, value) {
              this.#attributes.change(name, old, value);
            }
            get styles() {
              const styles = this.#widget.styles;
              return styles;
            }
            constructor(widget) {
              super({
                widget
              });
              this.#widget = widget;
              this.#attributes = new _attributes.WidgetAttributes(widget);
              const styles = new _styles.DependenciesStyles(this.specs.vspecifier);
              const links = () => [...styles.elements].map(style => style.href);
              !this.styles.initialised && this.styles.initialise(links());
              styles.on('change', () => this.styles.update(links()));
            }
            render() {
              try {
                this.mount();
              } catch (exc) {
                console.log(`Error mounting widget controller "${this.#widget.localName}":`);
                console.log(exc.stack);
              }
            }
            refresh() {
              this.unmount();
              this.render();
            }
            #refresh = () => this.refresh();
            /**
             * Comes from the web component disconnectedCallback method call
             */
            disconnect() {
              this.unmount();
            }
            async initialise() {
              if (!this.Widget) {
                throw new Error(`The return value of the Widget property is undefined. "${this.#widget.localName}" widget`);
              }
              this.#store = this.createStore?.();
              // Type check in widget is disabled due to the cyclical reference between controller and widget
              const prerender = this.#widget.ssr.prerender;
              if (prerender) {
                const cached = prerender?.store;
                await this.#store?.hydrate(cached);
              }
              this.#store?.fetch?.();
              this.render();
              // Attach to hmr changes of bundle of the widget controller
              if (!_bundle.instances.has(this.specs.vspecifier)) {
                console.log(`Bundle id "${this.specs.vspecifier}" not found. Try refreshing the page.\n` + `If the problem still persist, delete the BeyondJS cache and try again.`);
                return;
              }
              const pkg = _bundle.instances.get(this.specs.vspecifier).package();
              pkg.hmr.on('change', this.#refresh);
            }
          }
          exports.WidgetClientController = WidgetClientController;
        }
      });

      /****************************
      INTERNAL MODULE: ./controller
      ****************************/

      ims.set('./controller', {
        hash: 4127212824,
        creator: function (require, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WidgetControllerBase = void 0;
          var _render = require("@beyond-js/widgets/render");
          /*bundle*/
          class WidgetControllerBase {
            #specs;
            get specs() {
              return this.#specs;
            }
            get element() {
              return this.#specs.name;
            }
            get is() {
              return this.#specs.is;
            }
            get route() {
              return this.#specs.route;
            }
            get layout() {
              return this.#specs.layout;
            }
            #pkg;
            get pkg() {
              return this.#pkg;
            }
            // The widget component to be mounted should be specified by the module
            // (can be a React, Svelte, Vue, ... component)
            get Widget() {
              return;
            }
            createStore(language) {
              return void language;
            }
            /**
             * Controller base constructor
             *
             * @param {} specs
             * @param {HTMLElement} widget
             * The reason why it is declared as HTMLElement is to avoid circular reference between controller and widget.
             * @protected
             */
            constructor({
              specs,
              widget
            }) {
              if (!specs) {
                const {
                  localName
                } = widget;
                if (!_render.widgets.has(localName)) throw new Error(`Widget name "${localName}" is not registered`);
                specs = _render.widgets.get(localName);
              }
              this.#pkg = (() => {
                const split = specs.vspecifier.split('/');
                const scope = split[0].startsWith('@') ? split.shift() : void 0;
                const [name] = split.shift().split('@');
                return scope ? `${scope}/${name}` : name;
              })();
              this.#specs = specs;
            }
          }
          exports.WidgetControllerBase = WidgetControllerBase;
        }
      });

      /*********************
      INTERNAL MODULE: ./ssr
      *********************/

      ims.set('./ssr', {
        hash: 1515978368,
        creator: function (require, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WidgetServerController = void 0;
          var _controller = require("./controller");
          var _styles = require("@beyond-js/kernel/styles");
          /*bundle*/ /**
                      * The SSR widget react controller
                      */
          class WidgetServerController extends _controller.WidgetControllerBase {
            #styles = [];
            get styles() {
              return this.#styles;
            }
            constructor(params) {
              super(params);
              const styles = new _styles.DependenciesStyles(this.specs.vspecifier);
              styles.elements.forEach(({
                href
              }) => this.#styles.push(href));
              this.#styles.unshift(`##_!${this.pkg}!_##global.css`);
            }
          }
          exports.WidgetServerController = WidgetServerController;
        }
      });
      __pkg.exports.descriptor = [{
        "im": "./attributes",
        "from": "WidgetAttributes",
        "name": "WidgetAttributes"
      }, {
        "im": "./client",
        "from": "WidgetClientController",
        "name": "WidgetClientController"
      }, {
        "im": "./controller",
        "from": "IWidgetStore",
        "name": "IWidgetStore"
      }, {
        "im": "./controller",
        "from": "WidgetControllerBase",
        "name": "WidgetControllerBase"
      }, {
        "im": "./ssr",
        "from": "IWidgetRendered",
        "name": "IWidgetRendered"
      }, {
        "im": "./ssr",
        "from": "WidgetServerController",
        "name": "WidgetServerController"
      }];
      // Module exports
      __pkg.exports.process = function ({
        require,
        prop,
        value
      }) {
        (require || prop === 'WidgetAttributes') && _export("WidgetAttributes", WidgetAttributes = require ? require('./attributes').WidgetAttributes : value);
        (require || prop === 'WidgetClientController') && _export("WidgetClientController", WidgetClientController = require ? require('./client').WidgetClientController : value);
        (require || prop === 'IWidgetStore') && _export("IWidgetStore", IWidgetStore = require ? require('./controller').IWidgetStore : value);
        (require || prop === 'WidgetControllerBase') && _export("WidgetControllerBase", WidgetControllerBase = require ? require('./controller').WidgetControllerBase : value);
        (require || prop === 'IWidgetRendered') && _export("IWidgetRendered", IWidgetRendered = require ? require('./ssr').IWidgetRendered : value);
        (require || prop === 'WidgetServerController') && _export("WidgetServerController", WidgetServerController = require ? require('./ssr').WidgetServerController : value);
      };
      _export("__beyond_pkg", __beyond_pkg = __pkg);
      _export("hmr", hmr = new function () {
        this.on = (event, listener) => void 0;
        this.off = (event, listener) => void 0;
      }());
      __pkg.initialise(ims);
    }
  };
});
//# sourceMappingURL=controller.sjs.js.map