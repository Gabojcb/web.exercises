/************
Processor: ts
************/

// base\index.ts
declare namespace ns_0 {
  /**
   * Resolve the id of a module considering relatives paths to the source that is requiring it
   *
   * @param source {string} The module from where the require is being requested
   * @param id {string} The module being requested
   * @returns {string} The module processed with relative paths
   */
  import IMSpecs = ns_13.IMSpecs;
  export function resolve(source: string, id: string): string;
  /**
   * This class is used only by beyond/core
   */
  export class BeyondPackage {
    #private;
    constructor(exports: any);
    initialise(ims?: Map<string, IMSpecs>): void;
    /**
     * Solve the require function
     *
     * @param source {string} The module from where the require is being triggered
     * @param id {string} The module id being requested
     * @returns {*}
     */
    require(id: string, source?: string): any;
  }
}


// bimport\bimport.ts
declare namespace ns_1 {
  /**
   * Import a module, solving internally the module format (amd, esm).
   *
   * When running in a BEE, brequire and bimport are implemented by it, overriding both functions.
   *
   * @param resource {string} The resource identifier of the bundle
   * @param version {number} The version required by hmr to update a bundle's processor
   * @returns {Promise<*>}
   */
  export function bimport(resource: string, version?: number): Promise<any>;
  export namespace bimport {
    var mode: string;
    var resolve: (specifier: string, dependencies: any) => string;
  }
}


// bimport\brequire.ts
declare namespace ns_2 {
  /**
   * Require a previously loaded bundle synchronously:
   * (can be a project bundle or library bundle, or an external bundle).
   *
   * brequire is implemented for internal use, as the require function available in the internal modules
   * exposes this functionality.
   * In fact the require of the internal modules internally makes use of brequire.
   *
   * When running in a BEE, brequire and bimport are implemented by it, overriding both functions.
   *
   * @param {string} specifier
   * @return {*}
   */
  export function brequire(specifier: string): any;
}


// bimport\index.ts
declare namespace ns_3 {
  export {};
}


// bimport\requirejs.ts
declare namespace ns_4 {
  export interface Require {
    config: (config: any) => void;
    (modules: string[], ready: Function, errback?: Function): void;
    onError(err: any, errback?: (err: any) => void): void;
    undef(module: string): void;
  }
}


// bundle.ts
declare namespace ns_5 {
  import Package = ns_17.Package;
  import Module = ns_9.Module;
  import IModuleSpecs = ns_9.IModuleSpecs;
  export interface IBundleSpecs {
    module: IModuleSpecs;
    type: string;
    name?: string;
  }
  export class Bundle extends Map<string, Package> {
    #private;
    get type(): string;
    get name(): string;
    get vspecifier(): string;
    get specifier(): string;
    get module(): Module;
    get uri(): string;
    constructor(specs: IBundleSpecs, uri?: string);
    package(language?: string): Package;
  }
}


// events\index.ts
declare namespace ns_6 {
  import EventsSpecs = ns_7.EventsSpecs;
  import ListenerFunction = ns_7.ListenerFunction;
  import Trigger = ns_7.Trigger;
  export class Events {
    #private;
    get destroyed(): boolean;
    constructor(specs?: EventsSpecs);
    /**
     * Binds an event handler to an event name
     *
     * @param {string} event
     * @param {ListenerFunction} listener
     * @param {number} priority
     * @returns {this}
     */
    on(event: string, listener: ListenerFunction, priority?: number): this;
    bind: (event: string, listener: ListenerFunction, priority?: number) => this;
    /**
     * Unbind an event listener
     *
     * @param {string} event
     * @param {ListenerFunction} listener
     * @param {number} force
     * @returns {this}
     */
    off(event: string, listener: ListenerFunction, force?: number): this;
    unbind: (event: string, listener: ListenerFunction, force?: number) => this;
    /**
     * Triggers an event
     *
     * @param {Trigger} event
     * @param {*} rest
     * @returns {Promise<*>}
     */
    trigger(event: Trigger, ...rest: any): any;
    destroy(): void;
  }
}


// events\types.ts
declare namespace ns_7 {
  export interface Inherited {
    bind: (event: string, listener: ListenerFunction, priority: number) => void;
    unbind: (event: string, Listener: ListenerFunction) => void;
  }
  export interface EventsSpecs {
    supported?: [string];
    bind?: Inherited;
  }
  export type ListenerFunction = (...args: any) => void;
  export interface ListenerSpecs {
    listener: ListenerFunction;
    priority: number;
  }
  export interface TriggerSpecs {
    name: string;
    async?: boolean;
  }
  export type Trigger = string | TriggerSpecs;
}


// instances.ts
declare namespace ns_8 {
  import Bundle = ns_5.Bundle;
  export const instances: {
    register(bundle: Bundle): void;
    clear(): void;
    delete(key: any): boolean;
    forEach(callbackfn: (value: any, key: any, map: Map<any, any>) => void, thisArg?: any): void;
    get(key: any): any;
    has(key: any): boolean;
    set(key: any, value: any): any;
    readonly size: number;
    entries(): IterableIterator<[any, any]>;
    keys(): IterableIterator<any>;
    values(): IterableIterator<any>;
    [Symbol.iterator](): IterableIterator<[any, any]>;
    readonly [Symbol.toStringTag]: string;
  };
}


// module\index.ts
declare namespace ns_9 {
  export interface IModuleSpecs {
    vspecifier: string;
    multibundle?: boolean;
  }
  export class Module {
    #private;
    get pkg(): string;
    get vspecifier(): string;
    get specifier(): string;
    get version(): string;
    get subpath(): string;
    get multibundle(): boolean;
    constructor(specs: IModuleSpecs);
    /**
     * @deprecated
     *
     * @param {string} action
     * @param {Record<string, *>} params
     * @return {Promise<*>}
     */
    execute(action: string, params: Record<string, any>): Promise<any>;
  }
}


// package\dependencies.ts
declare namespace ns_10 {
  import Package = ns_17.Package;
  export class _default extends Map<string, any> {
    #private;
    constructor(pkg: Package);
    update(deps?: [string, any][]): void;
  }
}


// package\exports.ts
declare namespace ns_11 {
  import Require = ns_15.Require;
  /**
   * Interface is also required by @beyond-js/kernel/transversals
   */
  export interface IExportsDescriptor {
    im: string;
    from: string;
    name: string;
  }
  export class _default {
    #private;
    get values(): Record<string, any>;
    /**
     * Property is set by the bundle file, or by the transversal
     * @type {{im: string, from: string, name: string}[]}
     */
    descriptor: IExportsDescriptor[];
    /**
     * Property is set by the bundle file to process the module exports (es6, cjs, amd)
     * @type {(require: (id: string) => any) => {void(require)}}
     */
    process: (params: {
      require?: (id: string) => any;
      prop?: string;
      value?: string;
    }) => void;
    constructor(require: Require);
    set(key: string, value: string): void;
    update(): void;
  }
}


// package\ims\exports.ts
declare namespace ns_12 {
  import PackageExports = ns_11._default;
  import InternalModule = ns_13.InternalModule;
  export class IMExports {
    constructor(im: InternalModule, bexports: PackageExports);
  }
}


// package\ims\im.ts
declare namespace ns_13 {
  import Package = ns_17.Package;
  import Require = ns_15.Require;
  import Trace = ns_16.Trace;
  export type Exports = Record<string, any>;
  export type IMWrapperFunction = (rq: (id: string) => any, exports: Exports, trace?: Trace) => void;
  export type IMSpecs = {
    hash: number;
    creator: IMWrapperFunction;
  };
  export class InternalModule {
    #private;
    get package(): Package;
    get id(): string;
    get hash(): number;
    get created(): boolean;
    require(trace: Trace, source: InternalModule): Exports;
    initialise(): void;
    update(creator: IMWrapperFunction, hash: number): void;
    constructor(pkg: Package, id: string, hash: number, creator: IMWrapperFunction, require: Require);
  }
}


// package\ims\index.ts
declare namespace ns_14 {
  import Package = ns_17.Package;
  import Require = ns_15.Require;
  import Trace = ns_16.Trace;
  import InternalModule = ns_13.InternalModule;
  import Exports = ns_13.Exports;
  import IMSpecs = ns_13.IMSpecs;
  export type IMCreators = Map<string, IMSpecs>;
  export class InternalModules {
    #private;
    constructor(pkg: Package);
    set _require(value: Require);
    register(ims: IMCreators): void;
    require(id: string, trace: Trace, source: InternalModule): Exports;
    initialise(): void;
    update(ims: IMCreators): void;
  }
}


// package\ims\require\index.ts
declare namespace ns_15 {
  import Package = ns_17.Package;
  import InternalModule = ns_13.InternalModule;
  import Trace = ns_16.Trace;
  export class Require {
    #private;
    get pkg(): Package;
    constructor(pkg: Package);
    /**
     * Solve a cjs require function
     *
     * @param {string} specifier The id of the internal module being required
     * @param {Trace} trace {object} The internal trace to find cyclical dependencies of internal modules
     * @param {InternalModule=} im The internal module that is making the call
     * @return {*}
     */
    solve(specifier: string, trace: Trace, im?: InternalModule): any;
  }
}


// package\ims\require\trace.ts
declare namespace ns_16 {
  interface RequireTrace {
    source: string;
    id: string;
  }
  export class Trace extends Array<RequireTrace> {
    has: (id: string) => RequireTrace;
    register(source: string, id: string): void;
  }
  export {};
}


// package\index.ts
declare namespace ns_17 {
  import Bundle = ns_5.Bundle;
  import IMCreators = ns_14.IMCreators;
  import InternalModules = ns_14.InternalModules;
  import Exports = ns_11._default;
  import Dependencies = ns_10._default;
  import Events = ns_6.Events;
  export class Package {
    #private;
    get bundle(): Bundle;
    get language(): string;
    get vspecifier(): string;
    get specifier(): string;
    get ims(): InternalModules;
    get exports(): Exports;
    get dependencies(): Dependencies;
    get hmr(): Events;
    constructor(bundle: Bundle, language: string);
    get initialised(): boolean;
    initialise(ims?: IMCreators): void;
    update(ims: IMCreators): void;
  }
}


// package\instances.ts
declare namespace ns_18 {
  import Package = ns_17.Package;
  const _default: {
    register(pkg: Package): void;
    clear(): void;
    delete(key: any): boolean;
    forEach(callbackfn: (value: any, key: any, map: Map<any, any>) => void, thisArg?: any): void;
    get(key: any): any;
    has(key: any): boolean;
    set(key: any, value: any): any;
    readonly size: number;
    entries(): IterableIterator<[any, any]>;
    keys(): IterableIterator<any>;
    values(): IterableIterator<any>;
    [Symbol.iterator](): IterableIterator<[any, any]>;
    readonly [Symbol.toStringTag]: string;
  };
  export { _default };
}


export import bimport = ns_1.bimport;
export import brequire = ns_2.brequire;
export import IBundleSpecs = ns_5.IBundleSpecs;
export import Bundle = ns_5.Bundle;
export import Events = ns_6.Events;
export import ListenerFunction = ns_7.ListenerFunction;
export import instances = ns_8.instances;
export import Module = ns_9.Module;
export import IExportsDescriptor = ns_11.IExportsDescriptor;
export import IMSpecs = ns_13.IMSpecs;
export import IMCreators = ns_14.IMCreators;
export import Package = ns_17.Package;

