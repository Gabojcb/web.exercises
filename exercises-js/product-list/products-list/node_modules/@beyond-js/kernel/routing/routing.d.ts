/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from '@beyond-js/kernel/core';
// history\history.ts
declare namespace ns_0 {
  import HistoryPosition = ns_1.HistoryPosition;
  import HistoryRecords = ns_2.HistoryRecords;
  import Routing = ns_3.Routing;
  import RoutingMode = ns_3.RoutingMode;
  /**
   * Beyond keeps its own history list
   * @constructor
   */
  export class BeyondHistory {
    #private;
    get position(): HistoryPosition;
    get records(): HistoryRecords;
    get valid(): boolean;
    get current(): string;
    get initial(): number;
    replaceState(state: any, title: string, uri: string): void;
    pushState(uri: string, state: any): void;
    back(): void;
    forward(): void;
    constructor(routing: Routing, Mode: typeof RoutingMode);
  }
}


// history\position.ts
declare namespace ns_1 {
  /**
   * The position of the navigation is stored this way:
   *      1. In the state of each page (the history.state object), it is stored the position
   *         in which the page is located. To achieve this, the __beyond_navigation_position property
   *         is added to the state object.
   *      2. In the sessionStorage is stored the current position (__beyond_navigation_position)
   */
  export class HistoryPosition {
    check(): boolean;
    /**
     * Returns the position from the history.state
     * @returns {number | undefined}
     */
    get value(): number;
    save(position: number): void;
  }
}


// history\records.ts
declare namespace ns_2 {
  import HistoryPosition = ns_1.HistoryPosition;
  interface IHistoryEntry {
    uri: string;
    position: number;
  }
  export class HistoryRecords {
    #private;
    get valid(): boolean;
    get entries(): IHistoryEntry[];
    get length(): number;
    get current(): IHistoryEntry;
    get previous(): IHistoryEntry;
    get following(): IHistoryEntry;
    constructor(position: HistoryPosition);
    get(index: number): IHistoryEntry;
    /**
     * Push a uri to the records stored in the sessionStorage
     * @param {string} uri
     */
    push(uri: string): void;
    /**
     * Reset the list of records from the current position
     * This is required when:
     *      1. The list of browsed pages is greater than one (ex: page1 and page2)
     *      2. The user goes back in the history (ex: to position 1: page1)
     *      3. The user navigates another page (ex: page3)
     *
     * This method is required in step 3, to clean the records from position 1, and after this
     * execution, the navigation flow can push page3
     */
    reset(): void;
    updateCurrentURI(uri: string): void;
    save(): void;
  }
  export {};
}


// routing.ts
declare namespace ns_3 {
  import URI = ns_5.URI;
  import Events = __beyond_dep_ns_0.Events;
  import BeyondHistory = ns_0.BeyondHistory;
  export enum RoutingMode {
    Hash = 0,
    Pathname = 1,
  }
  export class Routing extends Events {
    #private;
    get mode(): RoutingMode;
    get history(): BeyondHistory;
    get initialised(): boolean;
    get ready(): Promise<unknown>;
    get uri(): URI;
    missing: (pathname: string) => Promise<string>;
    redirect: (uri: URI) => Promise<string>;
    constructor();
    pushState(uri: string, state?: object): void;
    replaceState(state: object, title: string, uri?: string): void;
    update: () => Promise<void>;
    setup(): void;
    back(): void;
    forward(): void;
  }
  export const routing: Routing;
}


// uri\querystring.ts
declare namespace ns_4 {
  export class QueryString extends Map<string, string> {
    constructor(search: string);
  }
}


// uri\uri.ts
declare namespace ns_5 {
  /**
   * Uri parser
   *
   * @param href {string} The href to be parsed
   * @constructor
   */
  import QueryString = ns_4.QueryString;
  export class URI {
    #private;
    get uri(): string;
    get pathname(): string;
    get search(): string;
    get qs(): QueryString;
    get hash(): string;
    constructor(uri: string);
  }
}


export import routing = ns_3.routing;
export import URI = ns_5.URI;

