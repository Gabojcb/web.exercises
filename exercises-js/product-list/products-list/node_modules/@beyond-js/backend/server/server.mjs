import * as dependency_0 from '@beyond-js/kernel/bundle';
import * as dependency_1 from '@beyond-js/kernel/core';
import * as dependency_2 from 'socket.io';
import * as dependency_3 from 'http';

const {Bundle: __Bundle} = dependency_0;
const __pkg = new __Bundle({"module":{"vspecifier":"@beyond-js/backend@0.1.5/server"},"type":"ts"}, import.meta.url).package();;

__pkg.dependencies.update([['@beyond-js/kernel/core', dependency_1],['socket.io', dependency_2],['http', dependency_3]]);

const ims = new Map();

/*************************
INTERNAL MODULE: ./bridges
*************************/

ims.set('./bridges', {hash: 2846923273, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bridges = void 0;
var _core = require("@beyond-js/kernel/core");
class Bridges {
  // The bridges' specification in production environment (not requested to the BEE)
  #bridges;
  #promise;
  async initialize() {
    if (this.#promise) {
      await this.#promise;
      return;
    }
    this.#promise = new _core.PendingPromise();
    const done = () => this.#promise.resolve();
    if (typeof globalThis.__bridges === 'object') return done();
    // In production environment get the actions from the actions.specs.json file
    const {
      specifier
    } = globalThis.__app_package;
    const specs = await bimport(`${specifier}/actions.specs.json`);
    if (!specs) return done();
    this.#bridges = new Map(specs);
    this.#bridges.forEach((specs, module) => {
      this.#bridges.set(module, new Map(specs));
    });
    done();
  }
  async get(module) {
    await this.initialize();
    if (this.#bridges) {
      const classes = this.#bridges.get(module);
      return Promise.resolve({
        classes
      });
    }
    // In development environment, request the bridges to the BEE
    const bridges = globalThis.__bridges;
    const response = await bridges.get(module);
    if (!response) return;
    const {
      errors
    } = response;
    if (errors?.length) return {
      errors
    };
    const classes = new Map(response.bridges);
    classes.forEach((methods, key) => classes.set(key, new Map(methods)));
    return {
      classes
    };
  }
}
const bridges = new Bridges();
exports.bridges = bridges;
}});

/****************************************
INTERNAL MODULE: ./connection/cache/cache
****************************************/

ims.set('./connection/cache/cache', {hash: 3870432203, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cache = void 0;
class Cache {
  #socketId;
  #cache = new Map();
  #times = [];
  #EXPIRATION = 30000; // 30 sec of expiration time
  constructor(socketId) {
    this.#socketId = socketId;
    setInterval(this.#clean, 1000);
  }
  #clean = () => {
    if (!this.#times.length) return;
    const expired = Date.now() - this.#EXPIRATION;
    let rq = this.#times[0];
    if (rq.time > expired) return;
    // Expire item
    this.#times.shift();
    this.#cache.delete(rq.key);
  };
  has(key) {
    key = `${this.#socketId}.${key}`;
    return this.#cache.has(key);
  }
  get(key) {
    key = `${this.#socketId}.${key}`;
    return this.#cache.get(key);
  }
  insert(key, value) {
    key = `${this.#socketId}.${key}`;
    if (this.#cache.has(key)) {
      console.error(`Cache key "${key}" already set`);
      this.update(key, value);
      return;
    }
    this.#cache.set(key, value);
    this.#times.push({
      'key': key,
      'time': Date.now()
    });
  }
  update(key, value) {
    key = `${this.#socketId}.${key}`;
    if (!this.#cache.has(key)) {
      console.warn(`Cache key "${key}" not set`);
    }
    this.#cache.set(key, value);
  }
}
exports.Cache = Cache;
}});

/***************************************
INTERNAL MODULE: ./connection/connection
***************************************/

ims.set('./connection/connection', {hash: 3244549256, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Connection = void 0;
var _executor = require("./executor/executor");
var _cache = require("./cache/cache");
const MaxActiveRequests = 60;
var State;
(function (State) {
  State[State["Executing"] = 0] = "Executing";
  State[State["Executed"] = 1] = "Executed";
})(State || (State = {}));
class Connection {
  #socket;
  #cache;
  #executor;
  #counter;
  #active;
  constructor(socket) {
    this.#socket = socket;
    this.#executor = new _executor.Executor(socket);
    this.#cache = new _cache.Cache(socket.id);
    socket.on('rpc-v2', this.#_onmessage);
  }
  disconnect() {
    this.#socket.off('rpc-v2', this.#_onmessage);
  }
  #_onmessage = message => this.#onmessage(message).catch(exc => console.error(exc.stack));
  async #onmessage(rq) {
    const socket = this.#socket;
    if (typeof rq !== 'object') {
      console.warn('Invalid rpc, request must be an object');
      return;
    }
    if (!rq.id) {
      console.warn('Action id not set');
      return;
    }
    const respond = response => {
      const {
        error,
        message,
        processingTime,
        source
      } = response;
      socket.emit(`response-v2-${rq.id}`, {
        error,
        message,
        processingTime,
        source
      });
    };
    if (this.#cache.has(rq.id)) {
      const cached = this.#cache.get(rq.id);
      if (cached.state === State.Executed) {
        return respond({
          message: cached.response
        });
      } else {
        return; // Continue waiting the response to be ready
      }
    }

    this.#cache.insert(rq.id, {
      state: State.Executing,
      requestedTime: Date.now()
    });
    this.#counter++;
    if (this.#active > MaxActiveRequests) {
      const error = {
        message: 'Max number of active connections achieved'
      };
      return respond({
        error
      });
    }
    this.#active++;
    try {
      const response = await this.#executor.execute(rq);
      const cached = this.#cache.get(rq.id);
      const processingTime = cached ? Date.now() - cached.requestedTime : void 0;
      this.#cache.update(rq.id, {
        state: State.Executed,
        requestedTime: cached.requestedTime,
        processingTime: processingTime,
        response: response
      });
      this.#active--;
      return respond({
        message: response,
        source: 'server',
        processingTime: processingTime
      });
    } catch (exc) {
      this.#active--;
      if (!(exc instanceof Error)) return respond({
        error: {
          message: exc
        }
      });
      const {
        message,
        stack
      } = exc;
      const {
        specifier
      } = globalThis.__app_package;
      const {
        local
      } = await bimport(`${specifier}/config`);
      const error = local ? {
        message,
        stack
      } : {
        message
      };
      console.log(stack);
      return respond({
        error
      });
    }
  }
}
exports.Connection = Connection;
}});

/********************************************
INTERNAL MODULE: ./connection/executor/action
********************************************/

ims.set('./connection/executor/action', {hash: 3788872330, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Action = void 0;
class Action {
  #error;
  get error() {
    return this.#error;
  }
  #rq;
  get id() {
    return this.#rq.id;
  }
  get module() {
    return this.#rq.module;
  }
  #className;
  get className() {
    return this.#className;
  }
  #method;
  get method() {
    return this.#method;
  }
  get params() {
    return this.#rq.params;
  }
  constructor(rq) {
    if (!rq.id) {
      this.#error = 'Action id not set';
      return;
    } else if (typeof rq.module !== 'string') {
      this.#error = 'Module id is invalid or not set';
      return;
    } else if (typeof rq.action !== 'string' || !rq.action) {
      this.#error = 'Action is invalid or not set';
      return;
    } else if (rq.params !== undefined && !(rq.params instanceof Array)) {
      this.#error = 'Invalid parameters';
      return;
    }
    // The first element is the relative file (without its extension) where the actions class is implemented
    const [, className, method] = rq.action.split('//');
    if (!className || !method) {
      this.#error = `Invalid class "${className}" or method "${method}" specification`;
      return;
    }
    this.#className = className;
    this.#method = method;
    this.#rq = rq;
  }
}
exports.Action = Action;
}});

/**********************************************
INTERNAL MODULE: ./connection/executor/executor
**********************************************/

ims.set('./connection/executor/executor', {hash: 3524280895, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Executor = void 0;
var _action = require("./action");
var _bridges = require("../../bridges");
class Executor {
  #socket;
  constructor(socket) {
    this.#socket = socket;
  }
  /**
   * Execute an action
   *
   * @param rq
   * @return {Promise<{response: (*)}|{error: module.exports.error}>}
   */
  async execute(rq) {
    const action = new _action.Action(rq);
    if (action.error) return {
      error: action.error
    };
    const {
      module,
      className,
      method
    } = action;
    const {
      errors,
      classes
    } = await _bridges.bridges.get(module);
    if (errors?.length) {
      throw new Error(`Errors found getting module "${module}" bridges: ${JSON.stringify(errors)}`);
    }
    if (!classes) {
      throw new Error(`Module "${module}" does not expose an actions bridge`);
    }
    if (!classes.has(className)) {
      throw new Error(`Module "${module}" does not expose a class "${className}"`);
    }
    const methods = new Map(classes.get(className));
    if (!methods.has(method)) {
      throw new Error(`Module "${module}" does not expose a class ` + `"${className}" with a "${method}" method`);
    }
    // Import the bundle
    let bundle;
    try {
      bundle = await bimport(module);
    } catch (exc) {
      throw new Error(`Error loading bundle "${module}": ${exc.message}`);
    }
    const Class = bundle[className];
    if (typeof Class !== 'function') {
      throw new Error(`Bridge "${module}" does not expose a valid class "${className}", it is not a function`);
    }
    if (!Class.prototype.hasOwnProperty(method)) {
      throw new Error(`Class "${className}" of bridge "${module}" does not expose a method "${method}"`);
    }
    const object = new Class(this.#socket);
    if (typeof object[method] !== 'function') {
      throw new Error(`Class "${className}" of bridge "${module}" ` + `does not expose a method "${method}", it is not a function`);
    }
    return await object[method](...rq.params);
  }
}
exports.Executor = Executor;
}});

/************************
INTERNAL MODULE: ./server
************************/

ims.set('./server', {hash: 550941318, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BackendServer = void 0;
var http = require("http");
var _socket = require("socket.io");
var _connection = require("./connection/connection");
/* bundle */ // import {instrument} from '@socket.io/admin-ui';
class BackendServer {
  #server;
  #connections = new Map();
  #onConnection = async socket => {
    const connection = new _connection.Connection(socket);
    const connections = this.#connections;
    connections.set(socket.id, connection);
    const disconnect = () => {
      connections.delete(socket.id);
      connection.disconnect();
      socket.off('disconnect', disconnect);
    };
    socket.on('disconnect', disconnect);
  };
  constructor(port) {
    const options = {
      serveClient: false,
      maxHttpBufferSize: 100000,
      cors: {
        origin: ["https://admin.socket.io"],
        credentials: true
      }
    };
    const server = http.createServer();
    const io = this.#server = new _socket.Server(server, options);
    // instrument(io, {auth: false});
    io.on('connection', this.#onConnection);
    server.listen(port);
    typeof process.send === 'function' && process.send({
      type: 'ready'
    });
  }
}
exports.BackendServer = BackendServer;
}});

__pkg.exports.descriptor = [{"im":"./server","from":"BackendServer","name":"BackendServer"}];

export let BackendServer;

// Module exports
__pkg.exports.process = function({require, prop, value}) {
    (require || prop === 'BackendServer') && (BackendServer = require ? require('./server').BackendServer : value);

};
export const __beyond_pkg = __pkg;

export const hmr = new (function () {
    this.on = (event, listener) => void 0;
    this.off = (event, listener) => void 0;
});


__pkg.initialise(ims);
//# sourceMappingURL=server.mjs.map