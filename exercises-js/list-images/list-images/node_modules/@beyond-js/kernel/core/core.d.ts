/************
Processor: ts
************/

// beyond.ts
declare namespace ns_0 {
  export class Beyond {
    /**
     * @deprecated
     * Use import {languages} from '@beyond-js/kernel/core';
     */
    get languages(): Languages;
    /**
     * @deprecated
     * Use bimport instead of beyond.import
     *
     * @param {string} resource
     * @param {number} version
     * @return {Promise<*>}
     */
    import(resource: string, version: number): Promise<any>;
  }
  export const beyond: Beyond;
}


// languages\index.ts
declare namespace ns_1 {
  import Events = ns_2.Events;
  export interface ILanguagesSpecs {
    default: string;
    supported: string[];
  }
  export class Languages extends Events {
    #private;
    get supported(): Set<string>;
    get default(): string;
    get current(): string;
    get ready(): Promise<unknown>;
    get fetched(): boolean;
    constructor(project: string);
    set current(value: string);
  }
  export const languages: Languages;
}


// utils\events\events.ts
declare namespace ns_2 {
  import EventsSpecs = ns_3.EventsSpecs;
  import ListenerFunction = ns_3.ListenerFunction;
  import Trigger = ns_3.Trigger;
  export class Events {
    #private;
    get destroyed(): boolean;
    constructor(specs?: EventsSpecs);
    /**
     * Binds an event handler to an event name
     *
     * @param {string} event
     * @param {ListenerFunction} listener
     * @param {number} priority
     * @returns {this}
     */
    on(event: string, listener: ListenerFunction, priority?: number): this;
    bind: (event: string, listener: ListenerFunction, priority?: number) => this;
    /**
     * Unbind an event listener
     *
     * @param {string} event
     * @param {ListenerFunction} listener
     * @param {number} force
     * @returns {this}
     */
    off(event: string, listener: ListenerFunction, force?: number): this;
    unbind: (event: string, listener: ListenerFunction, force?: number) => this;
    /**
     * Triggers an event
     *
     * @param {Trigger} event
     * @param {*} rest
     * @returns {Promise<*>}
     */
    trigger(event: Trigger, ...rest: any): any;
    destroy(): void;
  }
}


// utils\events\types.ts
declare namespace ns_3 {
  export interface Inherited {
    bind: (event: string, listener: ListenerFunction, priority: number) => void;
    unbind: (event: string, Listener: ListenerFunction) => void;
  }
  export interface EventsSpecs {
    supported?: [string];
    bind?: Inherited;
  }
  export type ListenerFunction = (...args: any) => void;
  export interface ListenerSpecs {
    listener: ListenerFunction;
    priority: number;
  }
  export interface TriggerSpecs {
    name: string;
    async?: boolean;
  }
  export type Trigger = string | TriggerSpecs;
}


// utils\execution-control\cancellation-token\cancellation-token.ts
declare namespace ns_4 {
  export class CancellationToken {
    #private;
    get current(): number;
    reset: () => number;
    check: (id: number) => boolean;
  }
}


// utils\execution-control\single-call\single-call.ts
declare namespace ns_5 {
  export function SingleCall(target: any, propertyKey: string, descriptor: PropertyDescriptor): PropertyDescriptor;
}


// utils\pending-promise\pending-promise.ts
declare namespace ns_6 {
  export class PendingPromise<T> extends Promise<T> {
    resolve: any;
    reject: any;
    constructor(executor?: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void);
  }
}


export import beyond = ns_0.beyond;
export import Languages = ns_1.Languages;
export import languages = ns_1.languages;
export import Events = ns_2.Events;
export import ListenerFunction = ns_3.ListenerFunction;
export import CancellationToken = ns_4.CancellationToken;
export import SingleCall = ns_5.SingleCall;
export import PendingPromise = ns_6.PendingPromise;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };