import * as dependency_0 from '@beyond-js/kernel/bundle';
import * as dependency_1 from '@beyond-js/kernel/core';

const {Bundle: __Bundle} = dependency_0;
const __pkg = new __Bundle({"module":{"vspecifier":"@beyond-js/kernel@0.1.9/routing"},"type":"ts"}, import.meta.url).package();;

__pkg.dependencies.update([['@beyond-js/kernel/core', dependency_1]]);

const ims = new Map();

/*********************************
INTERNAL MODULE: ./history/history
*********************************/

ims.set('./history/history', {hash: 1835933971, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BeyondHistory = void 0;
var _position = require("./position");
var _records = require("./records");
/**
 * Beyond keeps its own history list
 * @constructor
 */
class BeyondHistory {
  #position;
  get position() {
    return this.#position;
  }
  #records;
  get records() {
    return this.#records;
  }
  get valid() {
    return this.#records.valid;
  }
  get current() {
    return this.valid ? this.#records.current.uri : void 0;
  }
  #initial = history.length;
  get initial() {
    return this.#initial;
  }
  /**
   * Process the browser URI that takes into consideration the routing mode
   *
   * @param {string} uri The internal URI (always starts with '/')
   * @return {string} The URI to be pushed or replaced in the browser considering the routing mode
   * @private
   */
  #processBrowserURI(uri) {
    void this;
    if (uri === void 0) return;
    const {
      routing
    } = require('../routing');
    const RoutingModeEnum = require('../routing').RoutingMode;
    return routing.mode === RoutingModeEnum.Hash ? `#${uri.substr(1)}` : uri;
  }
  #push(uri) {
    this.#records.reset();
    this.#records.push(uri);
    this.#position.save(this.#records.length);
  }
  replaceState(state, title, uri) {
    state = state ? state : {};
    if (typeof state !== 'object') throw new Error('Invalid state parameter');
    this.#records.updateCurrentURI(uri);
    // The uri in the browser considering the routing mode
    const position = this.#position.value;
    history.replaceState(state, title, this.#processBrowserURI(uri));
    this.#position.save(position);
  }
  pushState(uri, state) {
    if (uri === `${location.pathname}${location.search}${location.hash}`) return;
    state = state ? state : {};
    if (typeof state !== 'object') throw new Error('Invalid state parameter');
    history.pushState(state, null, this.#processBrowserURI(uri));
    this.#push(uri);
  }
  back() {
    const previous = this.#records.previous?.position;
    const current = this.#records.current?.position;
    if (!previous) return;
    history.go(previous - current);
  }
  forward() {
    const following = this.#records.following?.position;
    const current = this.#records.current?.position;
    if (!following) return;
    history.go(following - current);
  }
  constructor(routing, Mode) {
    this.#position = new _position.HistoryPosition();
    this.#records = new _records.HistoryRecords(this.#position);
    if (this.#position.value === void 0) {
      // It is not a refresh of a previously navigated page
      let uri = routing.mode === Mode.Hash ? location.hash.slice(1) : `${location.pathname}${location.search}${location.hash}`;
      this.#push(uri);
    }
  }
}
exports.BeyondHistory = BeyondHistory;
}});

/**********************************
INTERNAL MODULE: ./history/position
**********************************/

ims.set('./history/position', {hash: 3613484025, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HistoryPosition = void 0;
/**
 * The position of the navigation is stored this way:
 *      1. In the state of each page (the history.state object), it is stored the position
 *         in which the page is located. To achieve this, the __beyond_navigation_position property
 *         is added to the state object.
 *      2. In the sessionStorage is stored the current position (__beyond_navigation_position)
 */
class HistoryPosition {
  check() {
    if (this.value) return true;
    console.error('History state is not defined. ' + 'This happen when state is changed outside the beyond defined navigation flows.');
    return false;
  }
  /**
   * Returns the position from the history.state
   * @returns {number | undefined}
   */
  get value() {
    return history.state?.__beyond_navigation_position;
  }
  save(position) {
    const state = history.state ? history.state : {};
    state.__beyond_navigation_position = position;
    history.replaceState(state, null);
  }
}
exports.HistoryPosition = HistoryPosition;
}});

/*********************************
INTERNAL MODULE: ./history/records
*********************************/

ims.set('./history/records', {hash: 3466552890, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HistoryRecords = void 0;
class HistoryRecords {
  #position;
  #valid = true;
  get valid() {
    return this.#valid;
  }
  #entries = [];
  get entries() {
    return this.#entries.slice();
  }
  get length() {
    return this.#entries.length;
  }
  get current() {
    return this.#entries[this.#position.value - 1];
  }
  get previous() {
    const previous = this.#position.value - 2;
    if (previous < 0) return;
    return this.#entries[previous];
  }
  get following() {
    const following = this.#position.value;
    if (following >= this.#entries.length) return;
    return this.#entries[following];
  }
  constructor(position) {
    this.#position = position;
    let parsed;
    try {
      const stored = sessionStorage.getItem('__beyond_navigation_records');
      /**
       * If user cleans site data, the session storage is deleted, but the history position state
       * remains, so set the records as invalid
       */
      if (!stored && position.value !== void 0) {
        this.#valid = false;
        return;
      }
      parsed = stored ? JSON.parse(stored) : [];
    } catch (exc) {
      this.#valid = false;
      console.error('Error loading beyond navigation state', exc instanceof Error ? exc.stack : exc);
      this.#entries = [];
    }
    if (!(parsed instanceof Array)) {
      const warning = 'The beyond navigation data, stored in session store is invalid.';
      console.warn(warning, parsed);
    }
    this.#entries = parsed;
  }
  /**
   * Set the URI always starting with '/' no matter the routing mode (hash or pathname)
   *
   * @param {string} uri
   * @return {string}
   */
  #sanitizeURI(uri) {
    void this;
    if (uri === void 0) return;
    return uri.startsWith('/') ? uri : `/${uri}`;
  }
  get(index) {
    return this.#entries[index];
  }
  /**
   * Push a uri to the records stored in the sessionStorage
   * @param {string} uri
   */
  push(uri) {
    uri = this.#sanitizeURI(uri);
    this.#entries.push({
      uri,
      position: history.length
    });
    this.save();
  }
  /**
   * Reset the list of records from the current position
   * This is required when:
   *      1. The list of browsed pages is greater than one (ex: page1 and page2)
   *      2. The user goes back in the history (ex: to position 1: page1)
   *      3. The user navigates another page (ex: page3)
   *
   * This method is required in step 3, to clean the records from position 1, and after this
   * execution, the navigation flow can push page3
   */
  reset() {
    const position = this.#position.value;
    if (position) return;
    this.#entries = this.#entries.filter(entry => entry.position < history.length);
  }
  updateCurrentURI(uri) {
    if (!this.#valid) return;
    const position = this.#position.value;
    uri = this.#sanitizeURI(uri);
    this.#entries[position - 1] = {
      uri,
      position: history.length
    };
    this.save();
  }
  save() {
    if (!this.#valid) return;
    sessionStorage.setItem('__beyond_navigation_records', JSON.stringify(this.#entries));
  }
}
exports.HistoryRecords = HistoryRecords;
}});

/*************************
INTERNAL MODULE: ./routing
*************************/

ims.set('./routing', {hash: 2780317025, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.routing = exports.RoutingMode = exports.Routing = void 0;
var _uri2 = require("./uri/uri");
var _core = require("@beyond-js/kernel/core");
var _history = require("./history/history");
var RoutingMode;
exports.RoutingMode = RoutingMode;
(function (RoutingMode) {
  RoutingMode[RoutingMode["Hash"] = 0] = "Hash";
  RoutingMode[RoutingMode["Pathname"] = 1] = "Pathname";
})(RoutingMode || (exports.RoutingMode = RoutingMode = {}));
const serverside = typeof process === 'object';
class Routing extends _core.Events {
  #mode;
  get mode() {
    return this.#mode;
  }
  #history;
  get history() {
    return this.#history;
  }
  #initialised = false;
  get initialised() {
    return this.#initialised;
  }
  #resolve;
  #ready = new Promise(resolve => this.#resolve = resolve);
  get ready() {
    return this.#ready;
  }
  #uri;
  get uri() {
    return this.#uri;
  }
  missing;
  redirect;
  #resolveConfigured;
  #configured = new Promise(resolve => this.#resolveConfigured = resolve);
  constructor() {
    super();
    // @TODO: move to some kind of initialization / setup
    const {
      specifier
    } = globalThis.__app_package;
    !serverside && bimport(`${specifier}/config`).then(({
      default: config
    }) => {
      let configured = config.routing?.mode;
      let routingMode = configured === 'hash' ? RoutingMode.Hash : RoutingMode.Pathname;
      location.protocol === 'file:' && (routingMode = RoutingMode.Hash);
      ![0, 1].includes(routingMode) && (routingMode = location.protocol === 'file:' ? RoutingMode.Hash : RoutingMode.Pathname);
      this.#mode = routingMode;
      this.#history = new _history.BeyondHistory(this, RoutingMode);
      this.#resolveConfigured();
    });
  }
  #redirect = async uri => {
    if (typeof this.redirect !== 'function') return;
    const redirected = await this.redirect(uri);
    if (!redirected) return;
    if (typeof redirected !== 'string') {
      console.error(`Invalid route value set by custom routing function`, redirected);
      return;
    }
    if (uri.pathname === redirected) return; // Routing function returned the actual route
    this.pushState(redirected);
    return true;
  };
  pushState(uri, state) {
    this.#configured.then(() => {
      this.#history.pushState(uri, state);
      this.update().catch(exc => console.error(exc.stack));
    });
  }
  replaceState(state, title, uri) {
    this.#configured.then(() => {
      this.#history.replaceState(state, title, uri);
      this.update().catch(exc => console.error(exc.stack));
    });
  }
  // Avoid to continue the execution on asynchronous calls, when a newest call's been made
  #cancellationToken = new _core.CancellationToken();
  update = async () => {
    const cancellationTokenId = this.#cancellationToken.reset();
    const {
      hash,
      pathname,
      search
    } = location;
    const _uri = this.#mode === RoutingMode.Hash ? `/${hash.slice(1)}` : pathname + search + hash;
    if (this.#uri?.uri === _uri) return;
    const uri = this.#uri = new _uri2.URI(_uri);
    // Check for uri redirect
    const redirected = await this.#redirect(uri);
    if (!this.#cancellationToken.check(cancellationTokenId)) return;
    if (redirected) return; // The page was redirected to another uri
    // Verify the state of the history registry to check for possible errors
    this.#history && uri.uri !== this.#history.current && console.error(`History current "${this.#history.current}" is not equal to actual uri "${uri.uri}"`);
    this.#initialised ? this.trigger('change') : this.#resolve();
    this.#initialised = true;
  };
  // Wait for start.js be completed, as routing.redirect must be set before initialising routing
  #started = false;
  setup() {
    this.#started = true;
    !serverside && this.update().catch(exc => console.error(exc.stack));
  }
  back() {
    this.#history.back();
  }
  forward() {
    this.#history.forward();
  }
}
exports.Routing = Routing;
/*bundle*/const routing = new Routing();
exports.routing = routing;
globalThis.routing = routing;
!serverside && (beyond.navigate = (uri, state) => routing.pushState(uri, state));
!serverside && (beyond.pushState = (uri, state) => routing.pushState(uri, state));
!serverside && (beyond.back = () => routing.back());
!serverside && (beyond.forward = () => routing.forward());
// Only on client side
!serverside && window.addEventListener('popstate', () => routing.update().catch(exc => console.error(exc.stack)));
}});

/*********************************
INTERNAL MODULE: ./uri/querystring
*********************************/

ims.set('./uri/querystring', {hash: 187911159, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueryString = void 0;
class QueryString extends Map {
  constructor(search) {
    super();
    if (search.trim() === '') return;
    search = search.slice(0, 1) === '?' ? search.slice(1) : search;
    const split = search.split('&');
    for (let i = 0; i < split.length; ++i) {
      const param = split[i].split('=', 2);
      const value = param[1] ? decodeURIComponent(param[1].replace(/\+/g, ' ')) : undefined;
      this.set(param[0], value);
    }
  }
}
exports.QueryString = QueryString;
}});

/*************************
INTERNAL MODULE: ./uri/uri
*************************/

ims.set('./uri/uri', {hash: 748332499, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.URI = void 0;
var _querystring = require("./querystring");
/*bundle*/ /**
            * Uri parser
            *
            * @param href {string} The href to be parsed
            * @constructor
            */

class URI {
  #uri;
  get uri() {
    return this.#uri;
  }
  #pathname;
  get pathname() {
    return this.#pathname;
  }
  #search;
  get search() {
    return this.#search;
  }
  #qs;
  get qs() {
    return this.#qs;
  }
  #hash;
  get hash() {
    return this.#hash;
  }
  constructor(uri) {
    this.#uri = uri;
    const [u, hash] = uri.split('#');
    const [pathname, search] = u.split('?');
    this.#pathname = pathname.startsWith('/') ? pathname : `/${pathname}`;
    this.#search = search ? search : '';
    this.#qs = new _querystring.QueryString(this.#search);
    this.#hash = hash;
  }
}
exports.URI = URI;
}});

__pkg.exports.descriptor = [{"im":"./routing","from":"routing","name":"routing"},{"im":"./uri/uri","from":"URI","name":"URI"}];

export let routing, URI;

// Module exports
__pkg.exports.process = function({require, prop, value}) {
    (require || prop === 'routing') && (routing = require ? require('./routing').routing : value);
    (require || prop === 'URI') && (URI = require ? require('./uri/uri').URI : value);

};
__pkg.initialise(ims);
//# sourceMappingURL=routing.mjs.map