import * as dependency_0 from '@beyond-js/kernel/bundle';
import * as dependency_1 from 'react';
import * as dependency_2 from 'react-dom/client';
import * as dependency_3 from '@beyond-js/widgets/controller';

const {Bundle: __Bundle} = dependency_0;
const __pkg = new __Bundle({"module":{"vspecifier":"@beyond-js/react-18-widgets@0.0.4/base"},"type":"ts"}, import.meta.url).package();;

__pkg.dependencies.update([['react', dependency_1],['react-dom/client', dependency_2],['@beyond-js/widgets/controller', dependency_3]]);

const ims = new Map();

/****************************
INTERNAL MODULE: ./controller
****************************/

ims.set('./controller', {hash: 2510685826, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactWidgetController = void 0;
var React = require("react");
var _client = require("react-dom/client");
var _controller = require("@beyond-js/widgets/controller");
var _widget = require("./widget");
var _wrapper = require("./wrapper");
/*bundle*/class ReactWidgetController extends _controller.WidgetClientController {
  #wrapper;
  #root;
  #mounted = false;
  get mounted() {
    return this.#mounted;
  }
  // This property must be overwritten
  get Widget() {
    return null;
  }
  mount(props) {
    if (this.#mounted) return;
    this.#mounted = true;
    if (!this.Widget) {
      return {
        errors: [`Widget "${this.element}" does not export a Widget class`]
      };
    }
    props = Object.assign({
      widget: this.widget,
      attributes: this.attributes,
      component: this.widget,
      store: this.store
    }, props ? props : {});
    const holder = this.widget.holder;
    const hydrate = !!holder.children.length;
    // Render the widget
    try {
      const wrapper = this.#wrapper = new _wrapper.Wrapper(this);
      const {
        styles,
        widget
      } = this;
      const {
        holder
      } = widget;
      const p = {
        wrapper,
        props,
        styles,
        holder,
        hydrate
      };
      const element = React.createElement(_widget.default, p);
      if (hydrate) {
        this.#root = (0, _client.hydrateRoot)(holder, element);
      } else {
        const root = this.#root = (0, _client.createRoot)(holder);
        root.render(element);
      }
    } catch (exc) {
      console.log(`Error rendering widget "${this.widget.localName}":`);
      console.log(exc.stack);
    }
  }
  unmount() {
    if (!this.#mounted) return;
    this.#mounted = false;
    this.#root.unmount();
  }
  refresh() {
    this.#wrapper.changed();
  }
}
exports.ReactWidgetController = ReactWidgetController;
}});

/************************
INTERNAL MODULE: ./styles
************************/

ims.set('./styles', {hash: 3645751033, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var React = require("react");
function _default({
  styles
}) {
  const rs = React.useState(0);
  // Listen for .css bundle changes
  React.useEffect(() => {
    const refresh = () => rs[1](prev => prev + 1);
    styles.on('change', refresh);
    return () => styles.off('change', refresh) && void 0;
  }, []);
  const head = [...styles.resources].map(url => {
    const loaded = () => styles.onloaded(url);
    return React.createElement("link", {
      key: url,
      href: url,
      rel: 'stylesheet',
      onLoad: loaded,
      onError: loaded
    });
  });
  return React.createElement(React.Fragment, null, head);
}
}});

/************************
INTERNAL MODULE: ./widget
************************/

ims.set('./widget', {hash: 90867181, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var React = require("react");
var _styles = require("./styles");
function _default({
  wrapper,
  props,
  styles,
  holder,
  hydrate
}) {
  const elements = [];
  elements.push(React.createElement(_styles.default, {
    key: "styles",
    styles: styles,
    widget: props.widget
  }));
  const rs = React.useState(0);
  const refresh = () => rs[1](rs[0] + 1);
  // Listen for .js bundle changes
  wrapper.changed = refresh;
  // Check for styles to be loaded
  const loaded = (() => {
    !styles.loaded && styles.ready.then(refresh);
    holder.style.display = '';
    return styles.loaded;
  })();
  const {
    Widget
  } = wrapper;
  const widget = React.createElement(Widget, {
    key: "widget",
    ...props
  });
  (hydrate || loaded) && elements.push(widget);
  return React.createElement(React.Fragment, null, elements);
}
}});

/*************************
INTERNAL MODULE: ./wrapper
*************************/

ims.set('./wrapper', {hash: 4175409966, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Wrapper = void 0;
class Wrapper {
  #Widget;
  get Widget() {
    return this.#Widget.Widget;
  }
  // Property changed should be overwritten to get notified about HMR changes
  changed = () => void 0;
  constructor(Widget) {
    this.#Widget = Widget;
  }
}
exports.Wrapper = Wrapper;
}});

__pkg.exports.descriptor = [{"im":"./controller","from":"ReactWidgetController","name":"ReactWidgetController"}];

export let ReactWidgetController;

// Module exports
__pkg.exports.process = function({require, prop, value}) {
    (require || prop === 'ReactWidgetController') && (ReactWidgetController = require ? require('./controller').ReactWidgetController : value);

};
export const __beyond_pkg = __pkg;

export const hmr = new (function () {
    this.on = (event, listener) => void 0;
    this.off = (event, listener) => void 0;
});


__pkg.initialise(ims);
//# sourceMappingURL=base.browser.mjs.map